{"./":{"url":"./","title":"Introduction","keywords":"","body":"Roppers Academy is a website dedicated to providing the best training possible for students who are new to the field. One of the ways that we do this is through a series of free courses. This the text version of the Roppers Academy Introduction to Computing Fundamentals course. It is a self-paced curriculum that was made to help our students over the first big learning hurdles and finally have a path forward. Our material is intended to be accessible for a student with no prior knowledge, but is worthwhile for any seasoned expert to take so that they can learn more about the subjects they have never had to dive into. Graduates of this course should be confident that they are fully prepared to continue their education wherever it leads. This site is generated from a course hosted at: https://www.roppers.org/courses/computing-fundamentals All the material is available here, but in order to get the full benefits of our course we recommend registering so that we can track your progress, grade your submissions, and provide feedback and support when you need it. If you have any questions, hit us on Twitter @roppersacademy. If you have recommended changes or feedback, this is all available on GitHub for anyone to submit issues or pull requests. Thanks for the help! LICENSE: Attribution-NonCommercial-ShareAlike 4.0 International Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"CourseOverview/0-CourseDescription.html":{"url":"CourseOverview/0-CourseDescription.html","title":"Course Description","keywords":"","body":"Hey! I'm Dennis, the person behind Hopper's Roppers. This is our free introductory course, teaching everything, and I mean everything, that a student needs to know about computers to have a successful career in a technical field. This is the first course in our roadmap which is our way of guiding students towards the best resources available, instead of overloading them with options and list of websites. In this course you will learn the fundamentals of computing, and get all the skills you need to learn whatever else you come across in your journey. You will be confident in the Linux environment, and be able to know how things work well enough to effectively troubleshoot any problem you come across. We won't make you into a hacker, but we'll give you the tools you need. Also, you'll earn a certificate that states you know enough to be considered dangerous. This course is not security specific and will be just as useful for someone who wants to be a web developer or an AI engineer as someone who wants to do information security. The fundamentals don't change, and are what you need to know to be successful in any field, and that's all we teach you in this course. If you already know fundamentals, there's still a lot your can get from this course. If you are looking for a course with a focus on cyber security, check out our Introduction to Security Fundamentals. If you are already confident in Linux and with programming and want to jump to the fun stuff, check out our Introduction to CTFs. We also have a Practical Networking Course if you are looking to get into some more difficult material. If you're still reading and know you want to build the foundation for the rest of your career, you're at the right place! Everybody asks for videos, but I don't find them very useful at all for teaching information. Students learn from doing, researching, and working towards solutions, not watching some guy in a Hawaiian shirt talk to them about computers. If you're looking for a video course with slick production quality, check out Cybrary or Udemy, but stick around long enough and you'll learn more here than you ever imagined. Thanks for joining us, see you around! Dennis Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"CourseOverview/1-TheShell.html":{"url":"CourseOverview/1-TheShell.html","title":"The Shell","keywords":"","body":"What is a shell? Basically, it is the command line interface that power users (from this point forward, that includes you) control their computer's operating system with. Windows has a shell, Macs have a shell, and the Linux operating system has a shell. Linux is the name of the operating system that you will be learning about for the rest of the course. For now, the only thing I want you to know is that one of the primary shells for it, named Bash, was written by Brian Fox, who is just a generally badass guy. His Wikipedia page is worth a read). So to go back over what we just said, the shell runs in the operating system which runs on the computer. In this course we will be teaching you a ton about the terminal on the Linux operating system, and then a little bit about the underlying computer hardware. Command Layout So let's get into how the real hacker uses the command line, starting with a scene from The Matrix, an all-time great hacker movie. That scene is actually pretty realistic, and a lot of the commands she runs are real things you will use throughout this course. Let's get into the format of commands. First, there is either going to be a $ or a #. Going forward, I will use a $ to indicate the beginning of a command. $ This indicates that you are in a shell of some format where you will be able to type a command. $ command When you run a command from the terminal, the shell is what will execute a program. These commands can do anything, from running a built-in program to the operating system, executing a script you wrote, the limit is what the command was programmed to do. We'll do a little programming in this course too! $ command We can also modify the program's behavior by adding what are called arguments. These arguments do things like configure settings, or tell programs to operate in a certain way to do something, and specify where to put output. To indicate an argument, we sometimes use something called a \"flag\" which says to the shell, hey, I am trying to modify the program that is running with the argument directly behind me. It looks something like this: $ command -f This command tells the shell to run the program \"command\" with the flag \"-f\" and the argument \"argument\". There can be dozens of flags and arguments to modify a command or how a program runs, so it gets complicated real quick. Luckily, there is a command named \"man\" we can use to find out what exactly those flags and arguments do to modify the command. We'll be best friends with \"man\" eventually, but for now, let's run our first commands! Usually we would run a shell on a computer (like the Windows 'cmd line'), or maybe in something known as a virtual machine which you will set up later in this course, but we have an even cooler option these days due to what can basically be described as dark magic: Shell In the Browser! The Shell in the Browser I will have you use for this section is a small Linux operating system with most of the same functionality as a fully featured shell. 1. Visit our online shell: Linux in the Browser. Sometimes it takes a bit to load (~10 seconds), if it takes longer, just press refresh. How it works and understanding what we are doing doesn't matter right now but by the end of the course, I guarantee you'll get it. 2. Once your in-browser Linux operating system has loaded, click into the terminal and enter your first command, 'whoami' and press enter. It should return \"root\", which is the name on the Linux operating system for the most powerful user on the system! On your journey through hackerdom, you will learn to love \"root\" and all the power it gives you, but for now, let's run a few more commands to see what is going on. 3. Run the command 'echo \"hello world\" '. It will use the command 'echo' with the argument \"hello world\" to print to the screen. Hello world is the classic programming introduction demo, so congrats on officially making it! 3. Next, type the command 'ls' (like LS, but lowercase, then hit the Enter key) to list all the files in the directory. 4. Let's take that one step further now and add a flag to that 'ls' command with 'ls -l'. (the -l is a lowercase L, not an i!) The '-l' flag allows you to see the long information printout for the files listed. 5. Now let's make a file of our own! Run 'echo \"hello world\" > newfile.txt'. This command will use the echo command to output the words and then use the '>' to redirect the words into a file we named. You'll learn all about redirection and what we can do with that in this course, but for now, create the new file and run 'ls -l' again. You should be able to see the new file and the updated time! (That time is off because the Linux operating system these commands are running in has their clock set to Coordinated Universal Time (UTC) but that is a completely different subject we'll ignore for right now) 6. There's a command named 'cat' on Linux which we can use to read files from the terminal. Use 'cat newfile.txt' to read the file you just created! 7. Run the command 'ls -al'. The \"-a\" flag makes it so you can see all files, and the \"-l\" flag allows you to see the long information printout for the files listed. Combined, they create this view. Whoah! Now we can see a hidden file named \".ash_history\". Linux hides files with a . in front of them from the normal \"ls\", but you can find them with \"ls -a\". 5. Let's use 'cat' to read the hidden file with 'cat .ash_history'. Now we can see all the commands that we ran so far!!! Congratulations! In this brief series of commands, we have figured out who we were, said hello to ourselves in a few ways, and found a hidden file. That's pretty awesome! Honestly, you weren't supposed to understand everything (or anything) you did there, but I promise, by the end of this course all of those things will make sense. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"CourseOverview/2-CourseLayout.html":{"url":"CourseOverview/2-CourseLayout.html","title":"Course Layout","keywords":"","body":" This self-guided course is designed to take around 100 hours and teach the most important things required to move on with your journey into computing and security. It is easy to get bogged down in details, but this course attempts to follow the most efficient path possible towards being able to accomplish whatever you need to do with Linux and programming. The first section is all about 'Improving You' and focuses on the non-technical side of life. The second section is the 'Site Intro' and explains some of the site's philosophy. The 'Mindset' section is all about the thought patterns we need to succeed in this field. These sections are meant to get you into the right mental state for learning this material. These sections are intentionally repetitive. I don't just want you to believe me, I want you to remember why you are doing this when you run up against a challenge. Finally, after learning the mindset, we get to what you joined this course for, 'Build a Lab and Learn Linux' where you will install a VM, learn the basics of Linux, and become very comfortable operating on the command line. You will also do your first CTF to demonstrate the skills you have picked up. After we are comfortable with Linux we will learn 'Programming' with Python as our first language. This section takes you from zero to writing larger programs and using Github and modern development practices to solve real world problems. It will culminate in a challenging capstone that will leave you ready for most problems you will come across. That's the end of our Fundamentals Course; from there you will be prepared for our follow on courses, depending on what you want to do next: Introduction to Capture the Flags Hardware and Operating Systems Windows Fundamentals Linux Fundamentals Networking Fundamentals Thank you for joining us! Guided Course With thousands of students, I can't grade every assignment that gets submitted in the free courses because it winds up being about a hundred submissions a day! If you want to check out the paid Guided Fundamentals Course, it is $50 dollars a month and in return, I grade all your assignments and you get exclusive access to me and the highly exclusive Daquiri Lounge community. I think it is a pretty good trade. The only difference between the free version vs. guided is that if you are enrolled in the guided course, I will be tracking your progress, grading your assignments, and making sure you are following along the timeline you set for yourself. If you are in the free version, I still care about you deeply and will answer questions you have in support channels, but I won't have the time to provide as much-individualized attention. I promise that myself and the community will take care of you no matter what. Working in a Group This course wants you to work in a group of two or more because I've found that it really improves your learning experience and you are much more likely to complete the course. If you don't have any friends working through this course with you, later in the first section I'll post a link to our messaging app where we have a dedicated channel for finding partners. Everyone needs to find partners so don't worry if you are here by yourself! If you have friends in the real world who might be interested in this, contact them or post on social media asking if they are interested in learning with you. Group accountability makes everything better! If you don't want to work in a group, totally cool. I'm not going to harass you for not being in one, plenty of people prefer to go it alone and use the community we have whenever necessary. Jump Ahead If you are here for technical material and want to jump right in, skip straight to 'Build a Lab and Learn Linux'. Personally, I think you're missing out on good stuff, but I'm not here to try to brainwash you if you don't feel like it, so just skip ahead. I promise it won't hurt my feelings. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"CourseOverview/3-RoppersYourResumeandPortfolioBuilding.html":{"url":"CourseOverview/3-RoppersYourResumeandPortfolioBuilding.html","title":"Roppers Your Resume and Portfolio Building","keywords":"","body":"While many people take this course to scratch an itch, some people are here so that they can learn the skills required to get a job and make a living in a technical field. However, in this day and age, knowing is not enough, you have to prove you know things. Certificates You are able to earn free certificates on Roppers, whether you are in the free or instructor-led courses. I'm never going to charge for them; they're for you, and maybe your future employer. You can earn three certificates by completing this course: The first is for completing our Virtualization and Linux sections, which will require you to install a VM and become proficient in the use of Linux, as well as complete a CTF. The second certificate is in the same form and you will receive it after completing our Programming section, which will have you build a website with HTML, CSS, and Javascript, learn how to use git properly, and complete a variety of projects in Python. The final certificate is for completing the entire course and states that you know enough to be considered dangerous. There aren't many of these badges in the wild yet, so don't expect your future employers to know what they represent. What will impress them is what your resume will look like once you are done with this course. Resumes and Portfolio Website You can't just sit here and watch videos to earn these certs. This is a practical, hands-on challenge that will fill out as many of the weak spots on your resume as we can. Here is the game plan: As you go through the course you will do a lot of technical writing. During the programming section you will build yourself a free website. Take those assignments you already wrote and turn them into blog posts. Take the Python projects you complete, write up a blog post on them and link to the code you have written. When you finish a CTF problem, do a writeup and post it on your site. Continue adding to this site any time you do something you want to write about. By the time you complete this course you will have a large, publicly accessible, constantly growing portfolio of work that says that you know what is going on. Update your resume accordingly. All of this will prove to potential employers you have what it takes to get things done. The certs we grant are nice and all, but what will impress people is what you have built. Speaking of resumes, once you're done with the free course I'll do a resume review for anyone who wants it. Sounds good? Already thinking about what your future resume will look like? Good! Go start the course! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"CourseOverview/4-SupportRoppers.html":{"url":"CourseOverview/4-SupportRoppers.html","title":"Support Roppers","keywords":"","body":"It has always been very important that this course would always be free. This comes down to a few key reasons, most of which can be summed up with: the world is a better place if anyone can learn the basics at any age, with no more resources than an internet connection. When I was younger and trying to figure out where to start, this is the exact resource I would have killed to find, and if I didn't give this away I'd be doing a disservice to the me's of tomorrow who need a free resource to get started. “If you’re not paying, then you’re not the customer. You’re the product.\" TL;DR: Roppers is free because I am the only employee, and I don’t plan on there ever being other employees. Because it’s just me, there are no salaries, and I minimize hosting costs by using free sites (thanks github and youtube). I care about privacy, so unlike some other freemium models, you and your data are not the product. If you are a representative of a company or organization who is interested in sponsoring this site, check out https://www.hoppersroppers.org/sponsors.html for more information. I see corporate sponsorship as the way forward for me to able to work on this site forever. If you are an individual who wants to support this mission, check out our Gumroad where you can make one-time or recurring donations. https://hoppersroppers.gumroad.com/ Overall, the best way for you to help out Roppers, and by extension me, is to share this site with as many people who are trying to enter the field as possible. My goal is for this to become known as the best place on the internet to start, and that can only happen with the support of students like you loving this course, learning a ton, and then sharing it with your friends and networks. With that out of the way, on to the course! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/0-SecureYourselfNow.html":{"url":"ImprovingYou/0-SecureYourselfNow.html","title":"Secure Yourself Now","keywords":"","body":"You signed up for this course to improve yourself, to learn how to secure yourself online, and to help others. That's what this section is dedicated to. If you finish this section and don't do anything else, your participation in this course will be a success in my eyes. Of course, I would prefer you to continue in the course, but I'm glad you are here, and I hope you stick around. If you have experience in this field you might know everything I am about to tell you, but I'm going to tell you it again. If you have strong opinions on things like this, you might not like that my advice defaults to a Windows OS and using Chrome. I don't have strong opinions on this, but they have the most market share and I am writing this for a very broad audience. If you are on a Mac, already running Linux, or use a different browser than Chrome, read along and just know some of the specifics will not apply to you. My first recommendation is to start using a password manager such as LastPass, Keepass, or 1Password. Even Apple and Google have built in ones for your browser these days. If you haven't heard of them before, what password managers do is recommend randomized passwords to you when you sign up to a site, store the password, and then autofill the password for you when you are logging into the site the next time. This is very helpful because the human brain can only remember so many passwords, which leads us to reuse passwords across different sites. The problem with this is that if you use the same password on all of your accounts, if someone steals that password at one site, they now have the ability to log into any of your accounts. Password managers help you maintain track of a bunch of strong, unique passwords, which limits the most likely threat that you have online. If you don't like trusting random internet people who tell you to download things in the first 5 minutes they know you, good call: I respect that. If you trust me, I recommend using LastPass. There's plenty of other great password managers out there, but I've been using this one forever and that is the main reason I recommend it. Convince your friends and family to use password managers. Again, I totally get if you don't want to do this now, just skip it. If you want to learn more about password managers, check this link out. Your second task, if you do not already have one installed, is to install an ad-blocking extension. Ad-blockers do what they say they do, making your web experience more visually attractive and faster, but also block trackers and lessen the chance of getting malware-laden ads. For Chrome, I recommend uBlock Origin: https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en. I don't use Firefox, but it has an ad-blocker built in which makes it one of the best choices for the privacy and security conscious. I also recommend installing Chrome and ad-blockers (or Firefox) on as many computers of friends and family that you do tech support for. Again, if you don't want to do this now, skip it. You always like to assume you don't already have malware on your computer but if you are working off of a shared computer, there are no guarantees. First, ensure that Windows Defender is enabled. If it isn't, turn it on. After you've done that, turn on automatic updates and ensure your computer is completely updated. If it isn't, update now. Once again, do this on as many computers as you are responsible for. I don't really recommend adding 3rd party antivirus solutions, so the best I can tell you is to avoid installing sketchy programs. If you believe that your computer has some sort of malware on it but Windows Defender isn't removing it, run MalwareBytes and see what if anything is detected. If MalwareBytes and Windows says you're good, you're probably good. I don't care much for VPNs because I don't care about ad tracking and I'm not in a country where I worry about my internet browsing being monitored and getting taken away by the secret police. You don't need a VPN for security no matter how many people are taking marketing money to sell them (use my code \"youdontneedavpn\" for 100% off). As long as you are using HTTPS sites and not clicking through bad certificates, you shouldn't have to worry about getting your credit card or passwords stolen no matter how sketchy the public wifi you're on is. If you reeeally want one for privacy, I trust Nord VPN and use them when I'm in countries that annoy me by blocking random parts of the internet. While some of this stuff might seem obvious, doing the fundamentals will make you significantly more secure than the average internet citizen. We're not trying to turn you into a cyber warlord yet, we'll start with being a hard target and generally informed. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/1-HowtoLearn.html":{"url":"ImprovingYou/1-HowtoLearn.html","title":"How to Learn","keywords":"","body":"We all want to better at learning... but how do we do that? It is essential to realize that there are no shortcuts. Nobody is really born an expert at anything, it all comes down to sustained hard work, directed at the right problems. Watching videos is not hard work. Reading books is not hard work. Following tutorials is not hard work. Those are hard truths, but you will never improve if you find yourself in a passive role while learning. You might \"learn\" some vocab words, but the way things fit together will never click. This course is designed to force you to work. It provides a resource or two (and sometimes just search terms) and tells you to go figure it out and return when you have the answer. The Paradox of Choice The hardest thing about teaching yourself how to be a hacker is not the material itself, but rather, how much material there is. When you look at a list of resources your eyes will glaze over and no matter how well you are able to visualize where you want to end up, you will struggle to find the next step forward, Azeria, a badass reverse engineer, wrote an article on this phenomenon named The Paradox of Choice. In it she describes the situation you are in right now, with big goals and infinite paths forward in front of you, as well as describing a mechanism for choosing which resources will get you towards your desired result. What sets this course apart is that we don't assume any knowledge and start from the absolute basics. We point you at your first step to take, and a task to ensure you understand what you just learned. Once you finish a task, we give you a clearly defined next step. And a step after that. And a hundred more steps after that. You don't have the ability yet to determine what the best resources for you are; so place your trust in us that we will take you on the most effective and efficient route. If at any point you get lost, or confused, or just need more motivation, there are mentors and tons of other people taking the course available to help. Another great piece by Azeria describes The Process of Mastering a Skill. It is a wonderful intro to the psychology of learning and who you are as a student, currently dipping your toes into the Apprenticeship stage. I want to really drive home some things she says in here: \"Move toward resistance and pain, avoid the easy path\". The original slogan of my site was \"The Slowest Way to Learn Security\", and I mean it, though I changed it because it doesn't do well for marketing. You must intentionally seek out what is hard, and what you do not know, and deliberately work through the problems you are face. The easy path towards feeling like you have learned something is watching a few hours of video courses and calling it a day. The hard way forward is lowering your shoulder and committing to Deep Work for a few hours of reading technical material, taking notes, and most importantly, getting hands on keyboard. \"Trust the process\". This course does everything in its power to take care of you and build you the best possible foundation for future success. Some parts of it are boring; a lot of it is hard. Some of it is both boring and hard. This is how it works, and you will have to put the time in. Nobody managed to cheat their way past putting in the hours with their hands on the keyboard. Nobody. While we're on this, I'm going to let you in on one more dirty secret. It is impossible to be an expert in all aspects of cybersecurity. Even the best people in one dark corner are total noobs in another. And that is fine, and is totally expected. There's too much out there to learn it all. Mastery is something you achieve of a very specific aspect of information security, not the entire kit and caboodle. All you can do is keep working at things and eventually, you will start understanding more because you have a strong foundation to build on. We are here to help you build that foundation. At the end of this course you will have learned enough to decide what you want to specialize in so that you can learn the skills you need to get a job in that specific skillset. We have courses to help with that as well, and we can provide help with resumes. As you go through this we will introduce you to other learning techniques, but to sum it all up: take notes, look back over the material regularly, and understand that the only thing that actually will contribute to future success is putting the time in now. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/2-ComputerRelatedHealth.html":{"url":"ImprovingYou/2-ComputerRelatedHealth.html","title":"Computer Related Health","keywords":"","body":"If you're going to be working through this course, competing in a Capture the Flag (CTF), or just binging Netflix because you deserve it, these are a few changes you can put into your life that will make you a happier and healthier person. Ergonomics We spend too much time in front of our computers, and over a long enough period of time, this can have negative effects on our bodies. We will summarize this quick guide to get you set up right. Monitor We want our monitors to be at an arms distance away, right at eye level This forces our necks to be up and our backs to not hunch Your monitor likely needs to be raised up on books to get to the right height Chair: Set your chair at a height where your feet are flat on the ground Adjust armrests so that your elbows and forearms are parallel to the ground This will require your keyboard to be at the same level as your chair, which often requires and under desk tray Mouse Use When using a mouse, keep on the same level as your keyboard and keep forearms straight Overall you want to minimize use and learn to use the keyboard, mostly so you look cool Laptops Laptops are terrible for ergonomics because of the monitor and keyboard being so close together The cheapest answer is to buy a USB keyboard/mouse so you can raise the monitor on a stack of books or similar items and have the keyboard at the appropriate level This is what I work off of the majority of the time. Sitting on a couch or in bed with a laptop is about the worst thing you can do for your back. If you are doing serious work, get to a desk with an appropriate setup Now fix your setup so that everything aligns properly. This is an investment in yourself. Hardware Required While we are on the subject of investments YOU DO NOT NEED TO BUY A NEW COMPUTER. My daily driver is a 8 year old Dell brick. There are students who have done this course on a Raspberry Pi. A significant number of students do it on an Android phone. While we all want a tower of hardware with six monitors and a light up keyboard, knowledge doesn't care what you are on, it just cares that you are putting in the work. Blue Light and Brightness Are you used to your eyes hurting after too long on the computer? Drop the brightness on your computer as far as you can. Just trust me. Blue light is slightly more complicated and while scientists don't all agree about the effects on eyesight, they're pretty confident about impact on sleep cycles. Windows 10has a built in Blue Light Filter Mac has Night Shift If you are on Linux use this link to find a method you're comfortable with. If you are on an old version of Windows that doesn't have it yet, just update to Windows 10 please. If you are a crazy person like me, go into the monitor settings and change the Red/Blue/Green distribution of the display. That way you can really take care of your eyes, but all the colors will be wacky. It is also an option to get blue light filtering glasses if you have money to blow, they're definitely not needed. If you want them, you should buy a pair from Blenders. I'm not sponsored, but I used to live next to them and they're a chill team so they deserve money. If we're really being honest, you can get cheap pairs from Amazon and they'll be like 1/5 the price and do basically the same thing. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/3-GeneralWellness.html":{"url":"ImprovingYou/3-GeneralWellness.html","title":"General Wellness","keywords":"","body":"Alright, forget about computers for a second, you only get one body and there are some pretty straightforward things you can build into habits to help future you out. Your behavior is the sum of your habits. Do the hard things and take care of yourself. Hydrate Constantly My life motto is \"Stay Happy and Stay Hydrated\", and it is inscribed in my class ring... so yeah, I take hydration seriously Trying to say how much water you should drink is too variable, you should be going to the bathroom every 2-4 hours Caffeine and alcohol, and especially drinks like coffee and energy drinks dehydrate you Hydration is slightly more complicated than water in/water out. Electrolytes are what actually provide hydration, so you basically can't go wrong adding extra electrolytes to your water. Sleep Everyone loves bragging about being a badass and sleeping four hours a night for months on end... guess what? It's not just stupid, it's actively hurting you in a variety of ways. Plus it doesn't make anyone think you are cool Sleep for seven or more hours a night if you can and basically everything improves Nutrition You and I know exactly what we are supposed to do, we just don't do it all the time Don't worry about specific diets, if you avoid drinking your calories (beer, soda, sugary drinks, etc) and eating processed foods (cheetos, hot pockets, pizza etc) you will be fine Cook your own food as much as possible, if only to be conscious of what you are putting in your body. Cooking is fun as hell and cheaper. Do it. Instant ramen doesn't count (but is delicious, and not too bad for you if you throw eggs in Fitness Not going to beat this one to death. Getting your heart rate elevated for a few minutes a day is good for you, full stop. Do it. Much like what I said about learning new things, you must work deliberately to improve. Working out 3x a week will put future you in a much better place than if you don't do it at all. Neurodiversity Our brains let us do amazing things, and the hacker community is known for our neurodiversity. Here are some resources to help understand what you or other people experience every day. Autism Spectrum Disorders Attention Deficit Hyperactivity Disorder Mental Health The more you know about these health concerns and their symptoms, the better you can understand them. Additionally, everyone needs more general suicide prevention and depression training. It's not fun, but it is worth having all the resources you can. Read all of these. Help yourself or help your friends. Depression Suicide Prevention Visit this link for resources on how to find a therapy provider. A ton of my friends say therapy can be life changing. If you are interested in more things like this there is a group named the Mental Health Hackers who are pretty cool and worth a look. More National Sexual Assault Hotline National Domestic Violence Hotline If you have any concerns that your internet activity may be monitored, call 800.799.SAFE (7233) for the National DV Hotline For more information about internet safety in the context of DV, click here Trans Lifeline If you have recommendations for other links or improved resources, let me know at d.m.devey@gmail.com. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/4-Questions.html":{"url":"ImprovingYou/4-Questions.html","title":"Questions","keywords":"","body":"Alright, you probably didn't expect this line of questioning in this course, and yet, here we are. Serious business time, three quick questions: Have you wished you were dead or wished you could go to sleep and not wake up? Have you actually had any thoughts about killing yourself? If so, have you thought about how you might do this? In the past three months, have you done anything, started to do anything, or prepared to do anything to end your life? If you are in the US and answered yes to any of these questions, visit https://988lifeline.org/ or call 988. If you are in the US, Canada, UK, or Ireland and you would prefer to text rather than talk on the phone, the Crisis Text Line https://www.crisistextline.org/text-us/ provides free, anonymous, 24/7 support. If you are international, check out this website http://www.suicide.org/international-suicide-hotlines.html or search for resources online, they are available to you. If you don't want to talk to a stranger, my name is Dennis, email me at d.m.devey@gmail.com or hit me in Slack. It's okay to not be okay, talk to someone. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/5-Why.html":{"url":"ImprovingYou/5-Why.html","title":"Why","keywords":"","body":"You thought you were here to learn how to get better at computers, so what is all this? Well, hopefully your end goal in life is that you become a better person and have a better life. If you want to be good at computers just for the sake of being good at computers that counts for something, but to me, all this technology is just a way for me to accomplish more than I could by myself. If you're going to be doing anything in this world, might as well take care of yourself first. Learning security comes far after you and your well-being. Now, on to the show! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/6-JoinourChatRooms.html":{"url":"ImprovingYou/6-JoinourChatRooms.html","title":"Join our Chat Rooms","keywords":"","body":"Click here to register for our Slack where you can ask questions and meet other students! Say hi to everyone in #helloworld! https://join.slack.com/t/hoppersroppers/shared_invite/zt-uqpgyl1e-wbZxSflcPsxQHmauT3TnNA Thinkific Community Only students enrolled in this course have access to this exclusive community. Check in and say hello, as well as ask any questions you have! https://roppers.thinkific.com/communities/Q29tbXVuaXR5LTE2MjU5 Checking In Communication is key in life, whether that is talking to your friends, getting advice, or writing blog posts to share what you know. Roppers is proud to have a Slack channel named #checkups, that is a dedicated space for people to talk about their journeys in life, whether that is educational, professional, or in their personal lives. You are more than welcome to use this channel to discuss mental health topics. If you are just looking to say hello and introduce yourself, use the channel #helloworld. If you just want to talk about something random, #random is perfect for that. Everybody deserves to have a place to vent or to get advice, and we're happy to provide one. Let me know any questions or comments in feedback for this section, or check it out in our Slack at #checkups! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/7-FindYourGroup.html":{"url":"ImprovingYou/7-FindYourGroup.html","title":"Find Your Group","keywords":"","body":"It's time for you to find the group of students you will be working through this course with! Science, and my experience running this course, show that students who work together --- finish together. If you have found three or more students already, good! Start that group chat and get to know each other! If you are still looking for partners, reach out in #findapartner on Slack and get the gang together! You can also ask your friends in real life or social media if they want to join you on this journey. Real world partners are even more effective to hold you accountable! Plus getting your group of friends into tech would be pretty sweet. If you want to work through this by yourself/don't feel like finding partners, I get it. Just keep working through the course and don't worry about it, you just gotta promise to reach out when you need help. Different Languages Roppers tries its best to be welcoming to people from all countries and backgrounds, but we are primarily English speaking. I wish I knew another language, but turns out seven years of a dead language like Latin is not particularly useful in the real world. Our Slack has multiple channels for different world languages. I'll make new ones on request, so reach out if you want your language represented. #roppers-espanol #roppers-francais #roppers-italiano #roppers-deutsch Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/8-SetYourLongTermGoals.html":{"url":"ImprovingYou/8-SetYourLongTermGoals.html","title":"Set Your Long Term Goals","keywords":"","body":"The most important thing you can do to increase your ability at a chosen task is to trust the process and put the time in. After that, studies show that one of the most important things you can do to increase your chances of success are to decide on, verbalize, and record your goals and the things you are doing to attain them. The majority of people who take this course do it to be better at computing and security fundamentals. Oftentimes this in pursuit of becoming a cyber security professional, but often times people just want to learn and see what the options are. To flesh those ideas out, put some time into your goals. What are your goals for taking this course and what are your long term goals in the fields of computing and/or security? If you want to submit those you can, but if if you don't know yet, or don't feel comfortable submitting them, that is completely understandable. You will also get credit for this section by submitting \"Why are you asking personal questions about me internet stranger?\" The answer is because I want you to think about it, and forcing you to type something out makes you really think about it. Kind of the philosophy for the entire course. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ImprovingYou/9-Motivation.html":{"url":"ImprovingYou/9-Motivation.html","title":"Motivation","keywords":"","body":"Entering the field of security is a long journey, with no shortcuts other than to keep moving forward. This means that you will have to maintain motivation over a long period of time, especially when things get hard. An interesting way to describe motivation is that it comes from when \"At some point, the pain of not doing it becomes greater than the pain of doing it.\" This means that you should focus on making it is easier to work at your end goal than it is to sit around and sleep. The easiest way for us to increase our motivation on an assignment or project is to sit around for as long as we can until procrastination endangers our ability to complete the task. Unfortunately, that doesn't work for learning this knowledge, because the times when you will be tested in daily life will be minimal. The only times that you will recognize the pain will be at job interviews, or in the course of your daily work when you are outside of your comfort zone. So what do we need to do to increase your motivation naturally? Luckily science gives us some answers. In the previous section, you completed one of the most commonly recommended actions: Verbalizing your Desired End State. Later in the course I will have you set small, measurable goals for how you will achieve your larger goal of completing this curriculum. For a third proven way to increase your motivation, look over the goals you wrote down in the first section and find a place to write them that will be visible to you, if you haven't already. My goals, both short and long term, are always written on a whiteboard above my desk. For a fourth, and perhaps the best way to motivate yourself, is to commit to your goals. The easiest way to do this is to pay for something, so you feel bad if you don't use it. I used to offer a paid instructor-led version of this course, but I don't anymore, so I've got nothing to shill. Another way to do the same thing is to make a public commitment that you will do it. Instead of spending money, now you spend social capital and are publicly committed to self-improvement. The reason this is most effective is that it adds external pressure (pain) on you to complete what you have started. When your friends, family, and random internet strangers are out there cheering you on, you are much less likely to want to give up. If you think posting about your goals and what you are up to will help you stay motivated, do that. When I started this site, I told all my friends and family about it to force myself to stay motivated and work all the way to completion. I also Tweet about my activity building the site, so I can keep myself honest about my progress. On the exact opposite side, there has also been research that has found that making a public commitment actually decreases your motivation because saying you'll do something feels better than doing it. So perhaps talking about your goals is actually bad???? Alright, this was confusing. Turns out humans are way more complicated than computers. The goal of this course (also life) is to learn yourself and figure out what works for you. Try different techniques and see what works. Just remember, there are no shortcuts or ways to force yourself to do this. Don't talk about it, be about it. See what motivation techniques help you out, but at the end of the day, you need to put the time in. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/0-LetterFromtheAuthor.html":{"url":"SiteOverview/0-LetterFromtheAuthor.html","title":"Letter From the Author","keywords":"","body":"Dedication This training is dedicated to the memories of Aaron Swartz, Bassel Khartabil and those named on the National Cryptologic Memorial. After a decade of teaching myself how to use computers and a few years training others, I went and made the site that I wish had existed when I got into the field back in middle school. Security is the shield of the modern world, and we need good people on the wall. Thanks for being up there. Hack the planet -Dennis Devey Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/1-Hoppers.html":{"url":"SiteOverview/1-Hoppers.html","title":"Hoppers","keywords":"","body":"This curriculum was initially built for my old school's competitive Cyber Security Team. I wound up naming the site after Grace Hopper because she is our favorite person in computing history. You might have heard of her before, but if not, click here to learn about a pretty awesome person. Have you ever heard the quote, \"It's easier to ask forgiveness than it is to get permission.\"? That was her. That quote comes from an interview in the July 1986 CHIP's Ahoy Magazine, the Navy's Information Technology Magazine. If you want to read the full interview check this out. She was at the cutting edge then and it is a testament to her vision how well this interview stands the test of time. Her passion for knowledge and innovation is the most important thing you can carry with you. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/2-Roppers.html":{"url":"SiteOverview/2-Roppers.html","title":" Roppers","keywords":"","body":"While there was a chance you guessed what Hopper's meant, it is very unlikely that you have had any idea what Roppers meant, mostly because it is a word I made up to describe a group of people who ROP. And if you have never heard of ROP, or Return Oriented Programming before.... that is not just okay, that is expected, because why on earth would you have known about that obscure hacking technique before this exact moment in time. To quote Wikipedia, \"Return-oriented programming (ROP) is a computer security exploit technique that allows an attacker to execute code in the presence of security defenses such as non-executable memory (W xor X technique) and code signing by chaining together carefully chosen machine instruction sequences to get control of the stack...blah blah blah\" Don't worry; none of that should have meant anything to you. That would have made zero sense to me when I was sitting where you are sitting. Two years into my journey, I would have understood about half of the words. Now I know what all the words mean, but I rely on my friends who know more than me if I need to do write my own. While other sites that attempt to teach this material assume you already know a great deal of knowledge, we take a different approach to make learning the fundamentals as approachable as possible. For all of the great resources out there, and all of the incredible pieces of training, nothing walks a complete beginner all the way through the process of developing a strong foundation in the fundamentals. Everyone wants to learn how to do stuff, but very quickly they realize that there is no way for them to learn everything. They're not wrong, the vast and constantly expanding body of knowledge about this field makes it impossible for anyone to keep up. But what is most important for the beginner to realize is that with the proper knowledge of the fundamentals and a firm grasp on the hacker mentality, that irrepressible drive to learn and to do, nothing is too complex for them to learn if they put the time in. By managing your high expectations of yourself, providing constant feedback on your progress, and bringing you into the community, Roppers is designed to provide the best first hundred hours of a cyber security education possible. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/3-CoreTenets.html":{"url":"SiteOverview/3-CoreTenets.html","title":"Core Tenets","keywords":"","body":" This site is designed around a series of ideas that we think will make your experience as a learner as positive as possible. No initial expectation of knowledge Everyone moves at their own pace Understanding foundational theory comes before building technical skills Developing fundamental technical skills lays the groundwork for success in any topic Knowledge must be actionable The measure of a community is how they treat those who are trying to gain entry There is no such thing as being done learning Anytime something on this site doesn't seem to be matching up with our core tenets, let me know so I can fix it. We made as many possible mechanisms for you to help us improve our approach, the content, and the community of this site as possible. This site is a living entity and changes on a regular basis so that we can improve your experience. So What is ROP? All you need to know right now is that ROP is an advanced exploitation technique which beats advanced defenses by chaining together the code which was already in a program. That definition is good enough for now, the critical bit to understand is that you take snippets of existing code, chain it back together in a new order, and then use those to jump to where you need to go next. As you go through this course you will do the same thing, gathering and rearranging information and skills you've already learned to jump to new locations. Nothing in this course is spoonfed, and while we try to give you good resources, there are multiple parts in the course where we tell you to go find out how to do something with Google. We do this when we know there are plenty of high quality resources out there for you to learn from and we want you to become comfortable accomplishing difficult tasks with no direction other than a couple searchterms. Content This curriculum was created based on inputs from members of my old team and various guides scattered throughout the internet on how to break into information security. I put this curriculum together by aggregating all of the guides and tutorials I could find, identified what I thought was important and added my own commentary. To say that this is built on the backs of a hundred other people's work would be an understatement, and I am forever grateful to be part of a community which has created so many amazing resources. All attempts to cite source material have been made, if there is anything I have not properly attributed, let me know. Despite having been in the works for the last four years, this is only the second iteration of the curriculum and it changes drastically as I see what does and doesn't work. The only way I learn the difference is feedback from viewers like you, so critique away. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/4-Legal.html":{"url":"SiteOverview/4-Legal.html","title":"Legal","keywords":"","body":"Community Guidelines Our community guidelines are available here: https://www.hoppersroppers.org/guidelines.html. I'll enforce them even if you didn't read them, so please read them over. Long story short, if you do anything that makes the community feel unsafe to any member, you will be banned. If you mention anything illegal, you will be banned. If you are an asshole, I'll call you an asshole, and then I'll ban you. Privacy Policy Our privacy policy is available here: https://www.hoppersroppers.org/privacy.html. Terms of Service Our terms of service are available here: https://www.hoppersroppers.org/tos.html. Legal Unsurprisingly, in this course you will learn some things that could be used to do bad things. You might not think they're bad things at the time, and they might seem like funny pranks, but the laws against hacking are very vague. If you have a security clearance or ever want one, having a pile of felonies you have to admit to is not a great look and will complicate your paperwork. As mentioned up in the community guidelines, if you even remotely talk about conducting illegal activities in a hypothetical manner, I will ban you on the spot. Makes my life easier when I don't have to worry about nuance. In the US, the law that surrounds this stuff is the Computer Fraud and Abuse Act. Basically, all you need to know is that every computer or account is a protected computer and that it is a crime to intentionally access, deface, or modify a computer or account without authorization. Sometimes the words \"exceed authorized access\" are used, and that vagueness is intentional. To stay on the safe side, only access computers and accounts you own, or have written consent to access. You're lucky, because we can help you find training boxes you can do whatever you want on. A lot of people don't, and that's where they get in trouble while trying to learn. It should also be mentioned that copyright law is also a good way to get in trouble, not to mention that if you see software to pirate on the internet, it is very unlikely that it doesn't contain malware. Just don't steal things, we can almost always get a copy of whatever you want, it just might take some paperwork and some emails. Classification Absolutely nothing on this site is classified, in any way, whatsoever. Nothing is derived from classified information. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/5-SubmitYourGroup.html":{"url":"SiteOverview/5-SubmitYourGroup.html","title":"Submit Your Group","keywords":"","body":"Earlier I asked you to find fellow students to work with for accountability throughout this course. You don't need to know them well now, but hopefully by the end of this you will be friends and have learned a ton together. I recommend you make yourselves a group chat to start talking to each other in, as well as ask questions and get your assignments reviewed. Submit the names of the three (or more!) partners you have found for this course. The more the merrier! If you want to work by yourself (and I respect that) just submit the text \"I promise I will ask for help when I need it and not stop when it gets difficult\". If you ever want to find yourself a group, the option is always open. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"SiteOverview/6-JoinUs.html":{"url":"SiteOverview/6-JoinUs.html","title":"Join Us","keywords":"","body":"Slack Instant group messaging has been a cultural staple of the internet community since its inception, as it is truly one of the most important functions that global interconnectedness can serve. Slack has become the messaging platform of choice, allowing group collaboration and real time chat along with various plug-ins and file hosting integration. We use it for many of feedback, support, as a forum, and as our primary instant messaging channel. At some point we might migrate to a self-hosted server, but for now, Slack is the easiest to work with. Join our channel at https://join.slack.com/t/hoppersroppers/shared_invite/zt-uqpgyl1e-wbZxSflcPsxQHmauT3TnNA and post a hello! Choose a nickname, or what we call online, a \"handle\" for yourself. Don't worry about it too much, you will come up with something good eventually, and you are not stuck with whatever you start with. As a general rule, don't call yourself something like \"Dark Shadow\" (Unless you want to, in that case, do that). I probably had a dozen or so before settling on my current one, 'deveynull'. I like mine because it is a nerd joke (that will be explained about halfway through this course) and incorporates my last name. Post a message in the channel #helloworld with a brief introduction to let the Roppers family know you joined. We use Slack for just about everything from helping on problems, submitting feedback, or just talking about random things. Optional: Twitter Unsurprisingly, information security Twitter is a very exciting place. In the modern age, where information flows at the speed of light, Twitter is the place to be if you want to stay informed and on the cutting edge. It is an overwhelming amount of information, so you want to start off following only a few accounts. It is going to be a lot for you right now to actually try to read and understand the firehose, so start slow and with a small number of beginner-friendly follows that really only post news. If you don't want to do Twitter yet, skip it, tis a silly place. If you decided you want to start wasting time on there, create a \"professional\" Twitter account! Remember, no matter how hard you try, this account will be able to be associated with you, even if you want to stay pseudo-anonymous. Always keep it fun and professional. Follow @HoppersRoppers on twitter so we can follow you. Again, if you don't want to do Twitter yet, just skip it. It is mostly just a giant waste of time, but it is very interesting and you learn a ton. If you want to, share that you started your journey with us on social media! This is called \"growth hacking\" by people who do marketing, and in theory it will help new students find Roppers. (No pressure at all, I wouldn't do it.) Begin Editing a Post on Twitter! Facebook We have just started a Facebook Group for Roppers at https://www.facebook.com/groups/hoppersroppers. Check us out and join our group there! LinkedIn We recently made a LinkedIn page! Follow us here and share with your connections! https://www.linkedin.com/company/hoppersroppers/ Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Mindset/0-ThisStuffisHard.html":{"url":"Mindset/0-ThisStuffisHard.html","title":"This Stuff is Hard","keywords":"","body":"I'm beating a dead horse here, but I want to make sure that you won't be surprised. There is an idea out there known as \"Effort Shock\" popularized by an article titled \"How the Karate Kid Ruined the Entire World\". If that sounds interesting to you, read it, but to summarize, most things worth doing take a very long time to get good at. What \"good\" is defined as changes, but I don't want you to be surprised at the amount of time it will take before you feel like you know what is going on. This course will probably take around 100 hours, possibly more. When you're done, you'll be able to do things, but you will likely feel like you know less than when you started. The whole wide world will have opened itself up to you, and right now, \"You don't know what you don't know\". By building your foundation and focusing on learning how to do things, you open yourself up to learn any subject you need to, depending on your interests or the requirements of your job. 100 hours isn't enough to make an expert, but on the plus side, 10,000 hours is wayyy more than you will need. If you spend two hours a day learning (~500 hours a year) it will probably take a year or two before you get comfortable. If you do it right, the moment you stop feeling totally lost you'll just start working on harder problems and you'll wind up more confused than you could imagine now. The most important skill you will learn is how to use all of your resources effectively to solve problems you've never seen before, whether that is your notes, classmates, teachers, reference pages, or Google. Mostly, Google. Being able to do things with computers is a long term process of reinforcing and building on the basic knowledge we will teach you in this course, and it will never end until you decide the computers have won. Don't let the computers win, and keep learning everything you can. To help learn, I really recommend posting in the #findapartner channel in our slack. If you haven't done it yet, you really should! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Mindset/1-HackerAttitude.html":{"url":"Mindset/1-HackerAttitude.html","title":"Hacker Attitude","keywords":"","body":"I've spent some time writing up what I think are the most important aspects of the hacker attitude and how a beginner can become a hacker. Read this: https://www.hoppersroppers.org/howtohack/ In one sentence, summarize why you feel the hacker attitude is useful. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Mindset/2-RTFM.html":{"url":"Mindset/2-RTFM.html","title":"RTFM","keywords":"","body":"One of the key parts of the mindset we are trying to develop is sharing knowledge with others. A great quote on the subject is 'There is nothing noble in being superior to your fellow man; true nobility is being superior to your former self.' If you're just starting off, you might not think you have anything to provide, but in fact, you're looking at the world with a different perspective than someone who has done it for years. For example, you can provide feedback on when training makes no sense or isn't as effective as it could be, and help make it easier for the next person to go through it. This site is a work in progress and the more feedback we receive the better it will be. So with that said, you're definitely going to have questions. A negative aspect about hacker culture is the idea that someone should \"Read the F***ing Manual\" or \"RTFM\". The first recorded use of this was in a user manual for some program in 1979, so it goes way back. On first glance, RTFM is a great response for any question that could and should have been answered by a casual glance at the manual. The problem with this response is that a large body of knowledge is usually required to understand the manual, and even before that, you need to know the manual exists. If you are taking this course, there is no possible way you can be expected to understand a manual because you are just getting started. Man-Pages The most common \"manual\" you will come across in this course and your travels through hackerdom are the man-pages that accompany every single aspect of the Unix operating system. Man-pages are short for manual pages, and they are a great resource for people who have spent time learning how to understand them. Right now, you don't have the knowledge to be expected to understand how they work, and that is fine. There is no pressure to know anything, but there is pressure to learn. In Defense of RTFM RTFM gets a bad rap for good reason, because it is usually used as a put down on someone who doesn't know much about a subject... with that said, once you have the knowledge to understand a topic, if you are using that software, you should read the documentation or man-page. Even if you don't understand the manual, if you are going to ask a question, you might as well reference that you know the manual exists and that what you are asking is referenced, you just need clarification. If you ask questions effectively you will find you understand your initial question and the topic much better than if you had someone explain the answer to just your specific question. Asking Questions To put it bluntly, you will never get a nasty response on Roppers for asking a question (Can't say the same about the rest of the internet). Anytime you find yourself lost in the sauce, I need you need to tell me so I can modify the course to help everyone else out. If the following tips on how to find answers for your questions don't work, post in the Slack in #course_computing, or in #techsupport if it is a general technology question. I will try to answer as soon as I can, or other members of the community will help you out. LLMs We are at the stage of the game where ChatGPT and other Large Language Models get the job done for most beginner Linux and programming questions. I recommend you make an account and use this whenever you have a question, even before you Google things. Right now I recommend Bing's implementation, that is likely to change. The New Bing - Learn More Google and Search Terms There are very few questions you are going to ask that Google can't answer, but for right now, you probably don't even know what you should be googling for. Luckily, you have people here who can help you. One of the best questions you can ask is for search terms on a subject. Post in #techsupport or #course_computing and phrase it along the lines of \"Hey I don't understand this, but I'm not getting great results. What are some search terms I should use?\". This is a great way to go about things because: a) That way the person answering doesn't have to spend time explaining it b) you get all the benefits of doing the research yourself Learning how to solve problems on your own is a critical skill, but don't worry about it for now. Not knowing what is going on is encouraged here at Roppers. You should always try to Google things, but if you can't find anything, there is no shame, let us know so we can help. WayBack Machine Some absolute legends at the Internet Archive are constantly backing up the internet (and everything else). When URLs break and websites go down, the pretty much magical Wayback Machine has your back! Check out how you can use it to look at old versions of sites: https://web.archive.org/web/20200801000000*/https://dfirdiva.com For some bonus content, here's me working with Jason Scott, one of the Internet Archivists! Cool dude and a sweet mission. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Mindset/3-Questions.html":{"url":"Mindset/3-Questions.html","title":"Questions","keywords":"","body":"We expect you to be constantly coming across words, phrases, and entire concepts that you have never seen before and are totally lost in. When you have to get things done, you'll have to learn more about it and one of the best ways to get those holes in your knowledge filled is to ask questions. Here are some guidelines for asking questions. There is no such thing as a bad question, especially on this site Write up your problem with as much information as possible Describe your problem's symptoms in chronological order Describe the goal, not the step you are on If you solve it later, follow up with a brief note on the solution Throw it on Slack on #course_computing or #techsupport, whatever. No one here will ever get annoyed, because there is really no such thing as a bad question. Even if your question isn't related to our courses, we are happy to help. If you're in person, just ask. It's faster than Googling and you'll get more out of it. The biggest thing we want to avoid is you sitting around banging your head against a boring problem. If it's interesting and you'll get something out of it, we want you to do it... otherwise, pass. We already told you what RTFM stood for, so now we're gonna have you do it. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Mindset/4-LLMsandRoppers.html":{"url":"Mindset/4-LLMsandRoppers.html","title":"LLMs and Roppers","keywords":"","body":"At this point, you've probably heard about, and maybe used, Large Language Models or LLMs, the near-magical technology that forms the basis of ChatGPT and a variety of other popular tools. Here at Roppers, we won't teach you about them at all, but we do expect you to use them in your pursuit of knowledge. They are truly the future, and figuring out how to use them in your workflows is going to be the new \"digital native\". Grow into security using LLMs and the speed you will improve will be shocking, but you have to use them the right way. LLMs are great at some things and terrible at others. They are great at vocab, providing definitions, rephrasing things, and coming up with semi-original content. They are pretty terrible at telling the truth all the time once they get to something they are uncertain about and begin to \"hallucinate\" anytime they wind up not having enough training data to \"know\" the right answer. Personally, I currently recommend Bing Chat. (July 2023) Link: https://www.bing.com/new The way that Bing interfaces with search is in my opinion the optimal way to use it right now. In this beginner course, ChatGPT is able to answer the vast majority of questions in the assignments. In fact, when I'm feeling like a mad scientist I actually use ChatGPT to review assignments! This seems very exciting (and it is), but you will quickly realize what LLMs are good for and what they are not. For Roppers, please do not submit LLM written answers, it's annoying and more importantly, you are trying to build skills and knowledge and if you don't do the act of writing yourself, it's not going to stick. What you should do is use LLMs like a search engine, specifically asking them technical vocab or programming syntax questions. You can ask LLMs to explain complicated concepts and use them as basically a somewhat knowledgeable friend to bounce questions off, and it will work pretty well, it just might make things up every once in a while. The good thing about asking technical questions is you can immediately check to see if those things are true. Throughout your journey, and especially at Roppers, use LLMs when the situation fits. You'll develop a sense of that over time and get better at prompting as you go. Some problems require the man page, and some problems require reading pages of documentation, but a great number these days just require the right question to an LLM. We're in the future! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/0-LinuxCertificate.html":{"url":"LinuxCommandLine/0-LinuxCertificate.html","title":"Linux Certificate","keywords":"","body":"Welcome to the Linux section of the Ropper's Fundamentals course. This is one of the longest sections, but I consider it the hump you need to get over for you to go from being someone who wants to learn things and someone who is really out there learning. It's a lot of work, but it is worth it. Plus, in the end you get a certificate! https://badgr.com/public/badges/6pOR4egxTpKJQZIgTodbqA Thanks for sticking around so far, let's go crush some Linux. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/1-FirstAssignment.html":{"url":"LinuxCommandLine/1-FirstAssignment.html","title":"First Assignment","keywords":"","body":"First Assignment Right now, I'm not expecting you to have any prior knowledge. If you do, some of the stuff here might be a bit basic, but I guarantee even an expert can learn a bit from each section. If you're brand new to this stuff, expect to learn an incredible amount. Your First Assignment In this course I like to have students submit short written assignments. As I cannot grade all of the assignments for the free courses, they are really for you to use to self-assess your understanding. If you want to check out the guided course, it is $50 dollars a month and in return, I grade all your assignments and you get exclusive access to me. I think it is a fair trade: Guided Fundamentals Course I have a specific format that I want you to fill out for each assignment, which will force you to think through what you are doing. First, there will be the questions I want you to answer. For example: Questions: 1. What is an operating system? 2. Describe what an operating system is responsible for. * (This is a trick question, it's everything.) 3. What is the world's most popular operating system? 4. What are the top desktop operating systems? Resources: 1. The previous section 2. Google For each of the questions I ask, I expect you to answer them with a sentence or two that will be enough for you to understand what you meant in the future when you study them. Every time you write up an assignment, treat it like you are making study material for future you, or someone you are trying to teach. Sometimes I will give you references, oftentimes I will make you Google for the resources yourself. Learning to pick out and use trusted resources is a major skill to learn. In this case, I gave you the resource. Looking at Wikipedia, there is a ton of information there, and each sentence has linked resources. In order to understand what is going on, you might have to go one level deeper to feel like you have a grasp of your answers. Please, don't get too deep into the rabbit-hole, just learn enough that you can answer the question and move on. Despite the Wikipedia page having information on the history and formatting and more of man-pages, stick to what you need to answer these questions and move on. Let's demo how I want you to try and do this going forward. Don't worry about things like plagiarism, though feel free to rewrite things however you want if it helps you understand better. Finally, I want your unfiltered, raw feedback, telling me exactly how you feel about this section. Feedback: Put it here and help me improve the material! Final Format To bring all of this together, the assignment you receive will look like this: Questions: 1. What is an operating system? 2. Describe what an operating system is responsible for. * (This is a trick question, it's everything.) 3. What is the world's most popular operating system? 4. What are the top desktop operating systems? Resources: * Previous Section I expect you to answer with a .txt file that looks like this: Answers:1.2.3.4. Resources:* https://en.wikipedia.org/wiki/Unix-like* https://en.wikipedia.org/wiki/POSIX Feedback:Most of this material made sense (except for the kernel diagram) but I don't understand this weird format.I sure hope you have some sort of master plan for this. For your first assignment, submit the text of the answer I provided above (but make sure to fill in the answers!) Feel free to add any Pre-Questions or Post-Questions if you have any. Note the feedback I gave myself. Despite this being meant to be straightforward, sections of it are too advanced for where we are right now, and that is perfectly okay. Make sure to give honest feedback about how you feel about the different assignments. For the entirety of the course, please only submit .txt files. No .docx files, no .odt, no .pdfs please! This makes review easier for me when I do it. On that note, I don't always get to read every answer because there are quite a few of you and only one me. Use the partner groups I had you make to submit your assignments and get feedback on them, They'll be able to help you with your pre and post-questions, as well as be supportive of what you are accomplishing! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/2-OperatingSystems.html":{"url":"LinuxCommandLine/2-OperatingSystems.html","title":"Operating Systems","keywords":"","body":"What is an operating system or OS? Most likely, just based off of your everyday use you have a pretty good idea about how to use Windows. However, what we are about to go over is what is actually occurring under the hood. For the everyday user of a computer, there is no need to know any of this, but as hacker, with the need to understand the underlying systems, learning the inner workings of operating systems is a necessity. In order to master the system you must remove the blind spots that will limit your ability to grow. Abstraction The technical word for these blind spots is \"abstraction\". Abstraction is a word that can be found outside of technical spaces to mean a way of removing specificity in order to understand more easily. To quote wikipedia: \"Conceptual abstractions may be formed by filtering the information content of a concept or an observable phenomenon, selecting only the aspects which are relevant for a particular subjectively valued purpose. \" This whole course I try to abstract away the things you don't need, so you are left with what matters. Similarly, Operating Systems abstract away the requirement for end users to be able to program or know how to set up a network connection, or really do most things with their computer. Everything is handled for the average user by the Operating System... but you are no longer the average user. Over the next few chapters we will remove more and more abstractions from our view of how computers work. Each abstraction we remove will show us an entirely new world of extraordinarily complicated material that was just below the surface. It might seem overwhelming, but remember, nobody understands all the abstractions. It is good to know they exist, and that there is something underneath where you are operating, but there is no need to fully understand the underlying technology to do great work. We don't have to care about any of this to be great, which is pretty amazing. Basics So what really is an operating system? In short, an OS is the interface between the end user and the computer hardware. To start, the hardware is generally controlled by something known as firmware, which is the code built into the electronics that tell them all how to run as individual components. Firmware is the OS for the hardware, but on a normal computer, is not considered part of the OS the user interacts with. Coordinating individual hardware components is the kernel, the core of the operating system, which coordinates those individual components so that the computer can run. Software, as we think of it, is the code that a user interacts with, but the kernel, even if we never interact with it directly, is still software as the core of the OS. Running on top of the OS is more software, which are what we think of as processes and programs. These user processes interface with the OS, which then do all the work with the kernel to ensure the processes work properly. Responsibilities of an Operating System We know that the OS is responsible for ensuring hardware is used appropriately, but what does that look like? First we have to think about what hardware is on a computer. Some important pieces of hardware are: Central Processing Unit (CPU) The circuitry which executes the instructions that the OS gives it. Don't worry too much about what this means beyond the idea that processes are a series of instructions that need somewhere to run, and it happens here. We'll get to that eventually There can be multiple CPUs in a computer, and multiple processes on a CPU. There is a ton of complexity here that we are able to abstract away. Thanks Operating Systems! Random Access Memory (RAM) RAM are chips that provide fast, temporary storage for information and is required for computers to run quickly. The OS uses RAM to ensure that the CPUs get the information they need. Input/Output (I/O) Devices Hard Drives/Storage Devices These storage devices are slow, but can contain a great deal of information. Data from 'file systems' is loaded into RAM by the operating system when needed. Mice/Keyboards The OS listens for mouse movements and key presses and responds so that a user can drive the OS. Monitors The OS displays what is going on so the user can see what is happening The OS doesn't need the monitor to run, but the user needs it ... and many more Now that we have discussed some of the hardware, we will discuss the most important roles of an OS. Processor Management: The OS prioritizes which processes are run by the CPUs at what time, ensuring smooth execution. Memory Management: The OS prioritizes what goes in RAM for the CPUs to access. If a CPU needs information and it isn't in RAM yet, the computer will run slowly. Device Management: The OS manages I/O Devices and passes them to different processes as required. File Management: The OS keeps track of files and organizes them, as well as passes access to different processes. Security: If defenses are programmed in, the OS attempts to identify unauthorized uses of files and memory and attempts to defends itself Logging and Error Detecting: The OS saves information as it runs to logs to enable troubleshooting of processes System Performance: In addition to Processor and Memory management, the OS keeps track of how processes and the OS as a whole are running, and will kill or pause processes as required for smooth operation Families There are a few major families of OSs, most notable Unix-Like and Windows. Both have a long history (and rivalry), but as you can see in the chart below, the open source UNIX has grown into a vast family of very different OSs, while Windows has steadily progressed to the modern Windows 10. You don't need to memorize anything in this, but it's good to know. UNIX-> Unix-Like -> Linux (The Most Popular OS for servers) -> Ubuntu, Debian, Fedora, Arch, Gentoo (Major Linux OS families) -> Android (Most popular OS in the world) -> Chrome OS -> Raspberry Pi Many many more -> BSD (Berkeley Software Distribution) -> MacOS (Partially Linux, mostly closed source) Many many more For a visual depiction of the Unix family: Windows is less interesting, but still worth pointing out the highlights. Windows - MS-DOS (1981) - Windows 1,2,3,95,98,ME,NT, 2000 (1985-2000) - Win. XP (2001) - Win. Vista (2006) - Win. 7 (2009) - Win. 8 (2012) - Win. 10 (2015) Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/3-LinuxHistoryandUbuntu.html":{"url":"LinuxCommandLine/3-LinuxHistoryandUbuntu.html","title":"Linux History and Ubuntu","keywords":"","body":"History of the Linux Kernel A kernel is the lowest level of the operating system that interacts with the hardware. You can consider the kernel the heart of the operating system. This means that once the kernel is written, you can build whatever OS you want on top. UNIX, the ancestor of Linux, was written by Ken Thompson and Dennis Ritchie at Bell Labs and was the first modern OS. They were just absolute studs. It was portable, meaning it could run on different hardware (which was a big deal at the time) and quickly became the OS of choice. However, because it was commercially licensed, some hackers (remember that absolute monstrosity of a Unix family tree?), and specifically a Finn named Linus Torvalds thought he could do better. Linus began writing a new kernel, now known as the Linux kernel, as a one-man show. After sharing it with the world and a few years of development with others this free, open-source, highly portable kernel began to take over the world. Better than anything else out there, Linux quickly rose in popularity and became the dominant Unix-like OS. Since then, more OS have grown around the Linux kernel, but Linus has held tightly to his philosophical and technical control of the kernel. The Penguin runs the show now, but in many different forms. Ubuntu As the Linux kernel was open-source, it was remixed and edited by plenty of people who had different philosophies. Competing OSs grew around the kernel and now there is a thriving ecosystem of open source Linux OSs. One of the most notable is Ubuntu. Ubuntu is an ancient African word meaning ‘humanity to others’. It is often described as reminding us that ‘I am what I am because of who we all are’. A group of developers banded together in 2004 and formed a company named Canonical, which is responsible for the Ubuntu operating system. They release Ubuntu for free, in addition to providing consulting services for companies which use Ubuntu servers. Ubuntu was derived from the Debian family of Unix-like OSs, so under the hood a lot of the OS looks like Debian. The primary difference between between Debian and Ubuntu is that Ubuntu is meant to be easy to set up and use for beginners, while Debian is targeted at a more advanced crowd. As a result of its ease of use, we will be using Ubuntu in this course. There are a lot of people who care deeply about Operating Systems and programs and which ones you use, but those people are wrong. Whatever is easiest to use for the task at hand is the correct option, and you should ignore their attempts at being ultra nerds. Smile and wave, especially if they are telling you about \"Gentoo\" or \"Arch\", then just go back to Ubuntu until you develop a preference for yourself. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/4-Shells.html":{"url":"LinuxCommandLine/4-Shells.html","title":"Shells","keywords":"","body":"Both Linux and Windows have CLIs that we will be operating with as power users. Linux: There are a variety of shells that exist in the Linux ecosystem, but the default for many OS's is known as Bash (Bourne Again SHell). You'll be best friends with this eventually. Windows: CMD A legacy interface that allows access to DOS commands MS-DOS was the first Microsoft OS and contained many basic features that are still accessible via CMD Powershell A fully featured interface and language that allows complex scripting via cmdlets and pipes. As the entire language was written for working with Windows, it allows fine grained control and easy manipulation of the OS. Windows Subsystem for Linux (WSL) - Windows 10 Only The Windows Subsystem for Linux lets developers run a Linux environment -- including most command-line tools, utilities, and applications -- directly on Windows, unmodified, without the overhead of a traditional virtual machine or dualboot setup. Basically, it's a mini-Linux VM, with access to all the same files on the host Windows machine. We won't be doing much work with Windows in this course, but for your first trick, open the shell by typing \"cmd\" and enter into the Windows search bar. Check to see your network settings by running the command \"ipconfig\" Just doing that and leaving the terminal open in the corner makes you look like you know what you are doing, even if you learn nothing else from this course You're welcome. Command Layout 1. Visit this online shell: JS Linux Browser Shell 2. Once it has loaded, use the command \"ls\" to list all the files in the directory. 3. Use the command \"cat readme.txt\" to read the contents of the file in \"readme.txt\". 4. In that file you will find 3 more commands to run. 5. Use \"cat hello.c\" to read the contents of hello.c. What do you expect to happen? 6. Use the first command in readme.txt \"gcc hello.c -o hello\" to create an executable named hello 7. Use \"ls\" to verify the creation of the new file. 8. Use the command \"./hello\" to run the new file Congratulations! In this brief series of commands, we have navigated a new system, found a file written in a programming language named C, turned that file into an executable program, and ran it! That's pretty awesome! Honestly, you weren't supposed to understand everything you did there, but hopefully you feel very cool! Don't worry about pre-questions for this section. Assignment Questions: 1. In your own words, describe what the command 'ls' does 2. Describe what the command 'cat' does 3. Describe what the command using 'gcc' does 4. Describe what the program ./hello did Resources: 0. Man Pages 1. Google Write up a few sentences for each of the questions. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/5-LearningLinuxCommands.html":{"url":"LinuxCommandLine/5-LearningLinuxCommands.html","title":"Learning Linux Commands","keywords":"","body":" Over the next few sections you will be learning the basic commands required to operate from the terminal in Linux. It is important to remember that there is no need to memorize... anything, at all, in this entire field, because you can always just have a series of cheat sheets and notes available to you. But the basics, like command line and text editing, will be used over and over again. In a best case scenario, you are now using Linux for everything and are getting a fully immersed experience. If you use the command line for everything it makes it so you don't even have to think about it eventually. The first resource you will always have on this journey, no matter what system, whether you have internet access, whatever, is man pages. If you are on Linux system, you should almost always be able to access an offline version of the man pages by typing '$man commandName'. For example, if you want to learn more about 'ls' you type '$man ls'. If your VM (or in this case a weird browser based emulator) doesn't have manpages, you can always use an online resource like https://man7.org/linux/man-pages/man1/ls.1.html. No matter what, if you want to learn how to use a command, you can figure it out because you always have access to the man pages. Something that is faster than looking it up in the man pages is to looking up longer commands on a cheatsheet. There is no expectation to remember every command and incantation, and there certainly isn't an expectation you build things from scratch every time. Not to mention, there are awesome cheatsheets out there. Also, you can make your own if you wind up doing specialized tasks often. I recommend you print one out now like this one and put it on your desk or tape it to the wall near you. If you don't have a printer or want to save ink, just save it to your desktop. When you find things you want to remember, write it on a separate piece of paper or in a text file on your desktop so you can consult it later. Another great resource is https://explainshell.com/. We can type commands into them, with all the associated flags, and we will get a human readable explanation of what is going on. I'd say, when I am doing stuff on the command line, about 50% of the time the commands are common enough for me to do off the top of my head. 20% of the time I use a cheatsheet I have nearby. 20% of the time I google the command I am trying to use and try to figure out the usage and flags required. \\ Finally, if I don't know the command, ~10% of the time I google \"how do I do ____ from linux command line\". So yeah, don't worry about memorizing anything now, but know that anything in the next few chapters you will want to memorize at some point. I recommend running through some of the little study guides linked at the bottom of the course to really drive it home. If you haven't found yourself a group to learn with, I really recommend posting in the #findapartner channel in our slack. If you haven't done it yet, you really should! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/6-CommandLineBasics.html":{"url":"LinuxCommandLine/6-CommandLineBasics.html","title":"Command Line Basics","keywords":"","body":" To start this off, pull up your terminal and let's get after it! If you already have a Virtual Machine installed, feel free to use that. If you don't have VM installed, or don't know what that is, don't worry, we will get to it! Visit this online shell: https://www.hoppersroppers.org/shell/ First command we are going to type will tell us who we are, which is clearly a badass. $ whoami The next command will tell us our path within directory, also known as our working directory. On Linux, we call folders directories because it sounds cooler, don't get thrown off. $ pwd Lets print out the long names of everything in our current working directory with ls -l. The -l is a flag that tells ls to print the \"long\" file information. $ ls -l This showed everything in our directory. Now let's go make a new directory inside this one to play in. $ mkdir linuxPlayground To enter this newly created directory, use the \"change directory\" command. Instead of typing out all of \"linuxPlayground\" use bash's autocomplete feature by pressing tab once you have a few characters typed, then press enter. This is super helpful, you can use autocomplete for basically anything. $ cd linuxPlayground Check where you are with pwd. List out the files in this new directory with ls -l. Unsurprisingly, it's empty. To get back to the previous directory, type the command. $ cd .. The \"..\" is a strange concept but basically means \"go up one level\". If you wanted to go up two levels, you would type cd ../.. Alright, cd back into the linuxPlayground directory. Once you are in there, let's print something to the terminal. $ echo Hello World! This is nice, but now let's save it to a new file. $ echo Hello World! > file1.txt That arrow is known as a redirector and can be used to redirect the output of commands to files. Now use ls to check how many files there are, you should see file1. Use the new command cat to read the contents of file1. Use the tab autocomplete so you don't have to type the whole thing. $ cat file1.txt Sweeeeet. We're starting to go somewhere. Now let's append (that means add to the back of) file1. $ echo Goodbye! >> file1.txt As a note, we used two redirectors there. If we only use one it makes a new file, but two redirectors tells the bash shell to append to the back of an existing file. Use cat to read file1. What do you see? Lets now make a copy of file1. $ cp file1.txt file2.txt Use ls to print out all files in your directory , then cat file2. Now use mkdir to make a new folder named folder1. We'll save this for later. Now let's learn how to delete file1. $ rm file1 Use ls -l and voila! file1 is gone! (you should also see folder1 now) While you have the results of ls -l up, look at what information is being shown for file2. The output of ls -l should look like this: drwxr-x--- 2 username groupname 4096 Jan 21 14:02 folder1 -rwxr-x--- 1 username groupname 15 Jan 21 14:02 file2 We won't beat this up too hard for now, but know that we can see: The first bit tells us what type of file it is \"d\" means directory \"-\" means normal file There are more options that can go here, but it doesn't matter for Now The next 9 bits are permissions bits You will learn more later, but they follow the read/write/execute format for the file owner/group/and others You don't really know what that means, so don't worry for now The next bit, a number, tells us how many hard links there are to the file, but don't worry about it The first name is the username who owns the file, in this case you The second name is the group who owns the file. Unless you've setup a group already, this should also be your username The next number is the file size in bytes Directories are always 4096, but individual files should be the number of bytes that make them up The next numbers should be the date and time last modified. These are not forensically accurate, but are good enough to sort by timestamp. Finally, the name of the file you are looking at the details of. Okay that was a bit, don't worry too much about permissions and links and groups, but refer back to this when you have questions, or just Google \"what does ls -l show\"... you'll probably get a better description than mine! Back to the command line!!!!! Run the touch command to update the timestamp on file2. $ touch file2.txt Use ls -l to verify the timestamp was updated. Touch also has the ability to make a new empty file with the timestamp set for now. $ touch file3.txt Use ls -l to verify the new file exists. We will use the command mv to move file3 into folder1. Use ls -l to verify the folder was created. $ mv file3.txt folder1/ Use cd into folder1 and use ls to verify file3 is in there. Alright, now let's delete folder1. Before trying to delete folder1, make sure you are actually in the correct path! If you are in folder1, the rm command won't be able to find folder1! Use $ cd .. to go back up the directory tree one step. You can try to use rm folder1 but it will tell you that folder1 is a directory. To delete it, use the \"-r\" flag, for recursive. rm -r folder1 will delete everything in folder1 recursively, including other folders underneath. This is a dangerous command as you can accidentally delete things with it if you rm -r the wrong directory. rm is unforgiving, if you delete with it, the files are gone and will not be saved in Ubuntu's Trash. Sure the file might still be on your hard drive, but you're probably not good enough for recovering that yet (we do that later in the course though!). rm is often referred to as a \"footgun\" in the nerd community, as you probably will shoot yourself in the foot with it at some point. Alright, that was a lot. We learned a ton of commands, and you're probably a bit stressed right now about what didn't make sense to you. Use the command history to pull up your most recent commands and leave them on the screen. Then work through it and take notes on what you still don't understand about what was described in this section. Submit anything you are confused about. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/7-BashInternalsandUnixPhilosophy.html":{"url":"LinuxCommandLine/7-BashInternalsandUnixPhilosophy.html","title":"Bash Internals and Unix Philosophy","keywords":"","body":"Unix Philosophy The Unix philosophy is a loose idea on how Unix OSs should be written and operate. In order to understand the Bash shell, an appreciation of this philosophy is recommended. To be clear, this is not written down anywhere in an official capacity, but is more of an oral tradition. From Doug McIlroy, an early Unix developer: \"This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.\" Under this philosophy, many of the design considerations that we see 40 years later make a lot more sense. When we are in the terminal, we are transported back to the old days where everything fit this philosophy. Modern programs don't care as much about these things because they are no longer limited by things like size, processing power, or connectivity, but when you are in the terminal, you're in the Unix world. Another core piece of the Unix philosophy is that \"Everything is a file\". By treating not just files and directories as streams of bytes exposed through the file system but also keyboards, printers, network connections, and process lists, Unix makes everything an Input/Output device. More on that later. POSIX In the early days of Unix, it rapidly gained popularity due to its \"manufacturer neutral\" design that allowed it to be run on most hardware. However, competing Unix distributions had slightly different implementations which caused programs to not work across them. The way to fix this was to create a standardized method of interacting with the kernel and other processes. This standard is now known as the POSIX Standard. By following this standard, programmers in any language could be confident that their software would be able to run on any platform because they all used the same Programming Interface. As a weird note, Bash itself is not fully POSIX-compliant, only POSIX-compatible. There is a ton of complexity there, but we will get away with ignoring it. What Does All of That Mean? Alright that was a bit rambling, but here's the takeaway. Everything in the terminal should be able to speak to each other, because everything speaks the language of text streams in the same way. We saw that in the last section where we ran echo Hello World! > file1. Let's get into that a bit. STDIO STDIO stands for Standard Input and Output. This standardized way of handling data streams, built upon the POSIX standard, allows all programs that use STDIO to be able to pass data between them in a controlled manner. Shoutout to a Ropper @Snoepie for writing up this helpful explainer: \" When we launch a program that is going to start taking input from a user using STDIO (standard input/ output), three data streams start (a data stream can basically be thought as the path the data will go in from and sent out to. These data streams are STDIN, STDOUT, and STDERR. The data streams of a key press would be: User presses letter A on keyboard, it is captured by STDIN. STDIN passes it to the system. The system interprets where STDOUT is currently. Usually STDOUT points to the users screen, and in this case the key press is successfully captured and sent to the screen via STDOUT No errors occurred so STDERR did nothing As mentioned above STDIN is often a key-press. It can also be a file we feed the system, or even another command we use. It can be looked at as the \"ear\" of the system or process we are working with. There is a thing related to file IO called a file handle. You can actually think of it as the \"handle\" the OS picks up a data stream with. File handle 0 is used to represent the STDIN data stream. The primary use of file handles is to shorten certain commands, but you do not need to worry about this too much for now. STDOUT is where the information received from STDIN is sent to. As in the above example this is usually the users screen. We can send info to files or commands however. In the example of \"$ echo \"hello world\" > hello.txt\". The standard out of echo (which we can look at as the mouth of the process) talks to the standard in of the \">\" which redirects the output to a file we now made called hello.txt. STDOUT has the file handle of 1, again not to important right now. Lastly we have STDERR. This does roughly the same thing as STDOUT, but for errors. It is just in a separate data out stream so that we can handle them differently and separately from the actual output we wanted. This can be useful for more complicated commands where we want to log the error data and the successful output data separately. This has the file handle of 2, again not sweat about the file handle. \" Thanks Snoepie for putting that in such a readable format. Here's a more complex diagram that should help as well. ) In summary, when an STDIO process begins, three data streams are opened: STDIN (file descriptor 0) Standard Input - Often keyboard presses, but can also be redirected from another file or command You can specify STDIN with 0, STDOUT with 1, STDERR with 2 if you want to shorten a command STDOUT (file descriptor 1) Standard Output - Sent to the terminal for display by default, but can be redirected into a file or another processes STDIN STDERR (file descriptor 2) Standard Error - Usually sent to the terminal for display, this is a dedicated stream that programmers can use to send error messages Independent of STDOUT, STDOUT can be hidden/redirected while STDERR can be displayed/redirected as required Practical STDIO Enough reading, back to the terminal. Let's go back over these commands now that we know what we are doing. Again, use a VM if you have it, otherwise, visit this online shell: https://www.hoppersroppers.org/shell/ In a new directory with nothing in it, run these commands. $ echo Hello World! > file1 $ echo Goodbye >> file1 Use cat to see what this looks like. Hopefully you aren't surprised what occurred. We called these > \"redirectors\" in the previous chapter, but what they actually do is take the STDOUT of the echo command, and send it to a file. Single '>' tells Bash to fill in file1 starting from the beginning, while two '>>' tell Bash to append (just a fancy word to add to the back) to the end of the file. How does Bash know where the end of the file is? Glad you asked. Basically, Bash walks through each character in file1 until there are no more characters to read, and then adds to that old stream and resaves it as a new stream. We can also use 1> to redirect STDOUT to a file because 1 is the file descriptor (FD). If we want to redirect STDERR to a file, we can use 2>, as 2 is the FD for STDERR. If we want to redirect STDOUT and STDERR to a file, we can use &>. This \"&\" represents both FD 1 and 2. There is a lot more to do with this, but this should be good for now. Pipe Alright, here is where it all comes together. The magic happens when we redirect the STDOUT of one command to the STDIN of another command using a pipe. Pipes are a form of redirection, but instead of going to files, the redirected streams go to other commands. Pipes are represented with | and are one of the more powerful tools we have as we can chain together commands. The Unix philosophy contains \"Write programs that do one thing and do it well\", so if we chain together programs using their STDIO text streams, we can do a lot of things well. It is important to note that pipes are unidirectional and only pass data from left to right. An example of what we can do with this is write a basic pipeline that can count the number of words in a file. Run these commands first to create a file filled with words. By using append (>>) we do not overwrite the original file. Hint: Use the Up Arrow key on your keyboard to see the last command you typed. Then all you have to do is change a small amount of the command instead of retyping it $ echo cat dog sheep cow dog cat > animals $ echo cat dog sheep cow dog cat >> animals $ echo cats >> animals To repeat a command, press the up arrow once and press enter. This will show: $ echo cats >> animals Use cat to verify what is in animals. You should see two lines of with the long list of animals, and two lines with just cats. Now, let's use some pipes. First, I will introduce the command named uniq. Use man uniq to learn what it does. Notably, it only checks for matching lines adjacently. Luckily, in animals right now, our matching lines are adjacent! So let's try out our first pipeline. $ cat animals | uniq The STDOUT of animals (four lines) is redirected to the STDIN of uniq which then checks for adjacent matches and removes them, leaving only two lines of output. Let's make this more complicated. Add another line of text to animals using echo cat dog sheep cow dog cat >> animals. Use the Up Arrow to navigate to that old command and run it again. At this point you should have five lines, with lines 1,2, and 5 matching. Let's run cat animals | uniq again and we will see what comes out. Unsurprisingly, we get three lines of output, with lines 1 and 3 matching. This is because uniq only sorts adjacent lines. To get around this, we can sort our lines ahead of time, using the command, sort. Check the man page for sort if you want to learn more, then run the pipeline with sort in the middle. $ cat animals | sort | uniq Now we got what we are hoping for! Only two lines, and both are unique. We can pipeline as many commands as we want together, which gives us a ton of programming ability just from the command line. As you learn more commands (or get comfortable using ones you don't know from cheatsheets) you will become more and more capable. For one more bit of fun \"\\ $ sort This gives us the same results as if we used cat on animals and redirected STDOUT to sort. Funky right? tee Alright, final thing for STDIO, promise. tee is a command named after T-shaped piping in real world plumbing. What it does is pass the STDIN from another command's output through, while also writing a copy to a file. Usage would look like this: $ cat animals | tee unsorted.txt | sort | uniq > sorted.txt Think about what just happened. For your assignment, write out what STDIN, STDOUT, and STDERR are and what they are doing for each of the commands. Answer in the usual format. Questions: 1. cat 2. tee 3. sort 4. uniq Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxCommandLine/9-CommandLineReview.html":{"url":"LinuxCommandLine/9-CommandLineReview.html","title":"Command Line Review","keywords":"","body":"I believe deeply in an educational theory known as spaced repetition. This is the best article on it but in short, the idea is instead of introducing material once and hoping you remember it later, the course creator designs in a variety of places where you will be forced to recall the material you have previously learned. By spacing this out over time, the connections in your brain get stronger and the chances you retain the information significantly increases. In this course we are going to do this by answering some questions from the previous couple sections. You might have the answers generally in your mind, but I recommend you go back to the content, maybe do a quick Google, and make sure your response covers what you need to answer the questions I ask. Don't worry about knowing the answers now, but the next time you get asked these, at the end of the next section, I bet you'll be a little faster. What is an operating system? Describe what an operating system is responsible for. Remember it is a trick question. What is UNIX-like? Who wrote UNIX? Describe the history of Linux. What is a shell? What is a GUI? What is a CLI? What are some resources to figure out what a command does? What is BASH? Describe STDIO? Don't worry about making these perfect, this is for you to learn!! This assignment is optional, so if you don't want to do this, just think about the answers and submit a file that says you are skipping this. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/0-Virtualization.html":{"url":"BuildaLinuxLab/0-Virtualization.html","title":"Virtualization","keywords":"","body":"Introduction Building your own home lab is important for a lot of reasons, but most importantly it is fun and teaches you a bunch of valuable information. In this section we will install a virtual machine for us to work on. What you will be making is uniquely yours and will be something that you will work on and refine for the rest of your time doing the computers. This is your new workbench/hangout spot, so take pride in what you are making and make it yours. Before we start, first we will learn about Virtualization. Virtualization Virtualization is when we run an operating system on top of another operating system. Using Virtualization software on the Host OS, the Guest OS or OSs are able to pass through to the Hosts hardware. By abstracting away from the hardware, it appears to the Guest OSs that they are all on their own dedicated machines. Virtualization software is known as a hypervisor. Hypervisors are programs used for running and operating the Guest OSs, which we refer to as Virtual Machines. By allocating resources and controlling when they turn on and off, hypervisors allow fine-tuned control as well as built-in automatic functions which contribute to stability. There are two primary types of hypervisors; \"bare-metal\" and \"hosted\". Bare-metal hypervisors run directly on top of a server and act like their own OS, managing all the things an OS does. Hosted hypervisors are programs that run on an OS like Linux, and have the OS handle the responsibilities. Hypervisors are able to run as many OSs as the underlying hardware can support, which is usually limited by RAM. Modern computers should have enough RAM to host at least one VM, but dedicated cloud servers can host hundreds of VMs at a time. Benefits of Virtualization The primary benefit of virtualization is the ability to share resources between multiple OSs, which allows us to have servers allocate resources as necessary. This is very beneficial for some server setups, as well as desktop users who need a different OS every once in a while. Another benefit is that we can save a VM and easily transport it to another system and know that it will work when we turn it on. Because the hardware is abstracted there is no concern that we will have compatibility issues. A third major benefit is that when we use a VM, we can be confident that we will not break the host environment with whatever we do in there. That means we can do whatever we want, like play around with malware or delete important files, and when we are done we can turn off the VM and revert back to its original state. Assignment Please respond in the format from the last assignment I demoed. The point of this assignment, and the format I ask you to respond in, is to teach you the thought processes you need to ingrain, along with stopping you from trying to learn too much too quickly. Even better, in later sections it helps me figure out what you don't understand so I can modify the material for other students. Write and answer the Pre-Questions that are required for you to understand your answer to the question that was asked. Only go one level deep into the rabbit hole, please, I have designed the course to only require one level deep max in order to confidently move forward. I greatly appreciate your feedback on how this attempt at question and answer works for you, either in #feedback or the question response. Some of these require Google. Remember, for this course, please only submit .txt files. No .docx files, no .odt, no .pdfs please! This makes review easier for me when I do it. Also, I don't always get to read every answer because there are quite a few of you and only one me. Use the partner groups I had you make to submit your assignments and get feedback on them, They'll be able to help you with your pre and post-questions, as well as be supportive of what you are accomplishing! Questions: 1. What is virtualization? 2. Why do we use virtualization? 3. What is the difference between the Host and a Guest VM? 4. What is the difference between a container and a VM? 5. What is the difference between VMs and the cloud? (Trick question) Resources: 1. Google Write up a few sentences for each in the usual format. Answers: 1. (the actual answer to the question) Resources: 1. (any helpful resources beyond what was given, especially if you had to google some of them) Feedback: 1. (any feedback on how the question was asked, the material, really anything) Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/1-VirtualizationSoftware.html":{"url":"BuildaLinuxLab/1-VirtualizationSoftware.html","title":"Virtualization Software","keywords":"","body":"The major step we need to take is to begin using Linux in our everyday life so that we can get comfortable in the environment we will be working from. If you are already using a Linux box as your home operating system, or already have a VM installed, skip this section: we are only building a VM so that we can learn in it. We will not do anything in this course that will break anything. Windows: There is something called Windows Subsystem for Linux or WSL for short, which allows you to run a Linux OS command-line only directly on your Windows machine. I don't totally recommend this, but it is very easy to set up and you should do it now anyway. https://learn.microsoft.com/en-us/training/modules/get-started-with-windows-subsystem-for-linux/2-enable-and-install I still recommend you install actual virtualization software so that you can use Linux tools which require the use of a Graphical User Interface (GUI). If you are on Windows 10 Enterprise, Pro, or Education, you can use Hyper-V, which is virtualization software built directly into the Windows operating system. Read this if you want to know more. Windows 10 Home edition (which you probably have) does not have Hyper-V. If you are on Windows 10 Home or are on an older version of Windows (which you shouldn't be because you update your OS), you have to use a different virtualization tool. I recommend VMWare Player, as that has been what I have always used, however there are many alternatives, primarily VirtualBox. Both VMWare and VirtualBox are significantly better than Hyper-V, you can't go wrong with either and there is a ton of documentation on both. Macs If you are on an older Mac you should use VirtualBox because it is free and generally works well on Macs. This is a pretty good link. Due to some very complicated computer engineering reasons, Macs running on the M1 processor don't work properly with VirtualBox (at this point in time). If you are using an M1 (jealous!!!) use the free version of VMWare Fusion. Chromebook/Other If you are on a locked-down computer that you can't install anything on like a Chromebook, or only have a mobile device, I highly recommend going and heading off to \"The Cloud\". Many companies offer online VMs for you to use, with a great free trial offering. I recommend using free Google Cloud for a pretty seamless browser based experience, and an app that works great for mobile access. If you don't can't do any of those things, https://www.hoppersroppers.org/shell/ will work to learn many things, but it only goes so far. NOTE: No matter what virtualization software you have installed, everything that happens inside the VM will remain the same so it will not hurt your ability to learn from this course. This should all be fairly straightforward because there are so many resources but will require some Googling, depending on what you are trying to install. If you have any problems that take more than 15 minutes to get through, post in #techsupport with your problem and someone will help you! As you work through the installation, I want you to practice creating documentation. Using the following format, write a brief walkthrough on how you installed the Virtualization Tool of your choosing. This is not meant to be a comprehensive tutorial on how to do this with images and full explanations, but rather, just enough to get yourself through the process again, and contain any notes on terminology or things you learned so that you can refer back in the future. If you already have a VM or were very confident in your ability to install, I don't expect there to be much in the way of steps or notes. Operating System/Version: Virtualization Tool: Primary Resources Used: 1. https:// 2. https:// Steps: 1. 2. 3. ... Notes: 1. 2. 3. ... An example step I would like to read is: \"1. Using Resource 1, follow steps 2-7 to ensure virtualization is enabled in BIOS \" An example note I would like to read is: \"1. BIOS is the firmware used to load an operating system and provides configuration options\" Don't beat yourself up making the walkthrough too detailed, this resource is for you. I want this to be heavy on resources, light on steps, and heavy on notes. Only briefly discuss the trouble-shooting process you took to fix things. When you submit the assignment it will be marked as complete. Hyper-V Notes: There are Virtualization Based Security measures on Windows that when enabled, will not allow you to run VMs other than inside of Hyper-V. If you are running Hyper-V and want to learn more, watch this. You won't understand most of it, but it is interesting and will explain why you will not be able to run a Virtual Machine on top of Hyper-V. Always know what you are disabling or doing before you run random commands off of the internet. In this case, you are disabling a few high level defensive measures that Windows provides for you, notably Credential Guard, Device Guard, and sandbox execution. This isn't terrible, but it does slightly increase your risk. Other Notes: Virtualization is ludicrously complicated and can simply be impossible on specific hardware. Hit up the support channel if you find yourself stuck. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/2-InstallUbuntu.html":{"url":"BuildaLinuxLab/2-InstallUbuntu.html","title":"Install Ubuntu","keywords":"","body":"Install the Linux operating system Ubuntu using your virtualization software of choice! We are going to use Ubuntu because it is largely agreed upon to be the most beginner-friendly and stable of all the Linux operating systems. There are plenty of other Unix-like OSs that are fine and do generally the same thing, but I strongly recommend you using Ubuntu to learn. If you already have a VM with a Linux image on it, you don't need to download a new one just for this course. It will not change any aspect of your experience and there is no need to waste time or space. An image is what we refer to an Operating System when packaged into a format that can be run off of a disc, usually having a .iso extension. We can download .iso's and boot off of the disc or using a USB, but it's generally easier to use a VM. https://www.ubuntu.com/download/desktop I could give you more information on what to do for this, but there are a ton of tutorials and Youtube videos out there. Should be an easy Google, and the information doesn't change too much. Let us know if you have any problems, but I recommend going step by step through a tutorial. This is your first challenge that we are really telling you to figure it out yourself. Source: TheSquareComics We always try to link to the source of things, even dank memes. It's a weird thing to care about, but the internet makes it so easy to repost images without any way of crediting the author, and they're producing content so might as well throw them a follow. Memes aside, if you get confused, hit us up in #techsupport in Slack. We are happy to help, and this is very complicated. When you're done, mark this section complete and move forward! Tips If the VM is running slowly, check out how much RAM and the number of CPUs you have allocated to it. Whatever the recommended settings are is probably good. Another major cause of poor performance is if the resolution is set too high. Lower the resolution and the host OS won't get slammed trying to render the VM window. If you are using Hyper-V, turn on \"Enhanced Sessions\" for better performance. If you're having trouble with anything or it is slow/freezes, hit us up in #techsupport in Slack. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/3-VirtualizationTools.html":{"url":"BuildaLinuxLab/3-VirtualizationTools.html","title":"Virtualization Tools","keywords":"","body":"Virtualization tools are pieces of software that connect your host OS with your new VM. You need this for a lot of critical usability things, and usually it doesn't come pre-installed. These virtualization tools are responsible for passing files and clipboard material back and forth, adjusting monitors, and overall ensuring the Host-VM experience is stable. I'll be honest, getting this working can be kind of difficult sometimes, but you have to figure your own way through this. Again, if you have any trouble, and this takes more than a half hour to figure out, message us in #techsupport and we will help you out. There is no shame, I've had VMs before that I gave up trying to install VMWare tools and just sucked it up for a week. You'll be on this VM for a while, so you need to get it installed. Before you waste any time trying to install things, you might have already done it during your VM installation. The easiest way to test if VMWare Tools or VirtualBox Guest Addons is installed is to try to copy and paste a file from your host OS to the VM. If it works, you're good! If you are using Hyper-V, it should be done. If you are using VMWare, you need to install VMWare Tools for Ubuntu. https://linuxize.com/post/how-to-install-vmware-tools-in-ubuntu-18-04/ If you are using VirtualBox, follow this guide to install the VBox Guest Addons. https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/ Again, check to make sure it worked by moving files between the Host and the VM. My personal recommendation is to open the file browser in your VM and drag and drop into there. For some reason the Ubuntu Desktop doesn't work nearly as well. If you have any trouble, reach out in #techsupport for assistance. When complete, mark complete and move forward. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/4-MakeitYourOwn.html":{"url":"BuildaLinuxLab/4-MakeitYourOwn.html","title":"Make it Your Own","keywords":"","body":"For your first trick, we are going to modify your wallpaper entirely from the command line. This only works if you are in a Gnome-based desktop environment, which you would have if you installed Ubuntu. I can't promise anything if you are in another OS, so run this: echo $XDG_CURRENT_DESKTOP If it doesn't say Gnome, just skip this section, or for bonus points, figure out how to change your wallpaper from the command line using Google. First we have to download an image, and then we will use the command to make it our background. $ wget -O ~/Downloads/wallpaper.jpg \"https://raw.githubusercontent.com/hoppersroppers/hoppersroppers.github.io/main/_layouts/constitution.jpg\" $ gsettings set org.gnome.desktop.background picture-uri file:////tmp/wallpaper.jpg Now your background image should be a picture of a ship! If it didn't work, troubleshoot. If you're not on Ubuntu there is a very strong chance that you have a different default Desktop (aka GUI) environment on your OS and it doesn't use 'gsettings'. Google around to figure out which Desktop environment you have and what you need to do to change your background from the command line. Alright, you don't need to keep it like that, go make it whatever background you want! Assignment Questions: 1. Using the 'man' command, describe what the command using wget and the -O flag did 2. Using the 'man' command, describe what the command using gsettings did. If that didn't work, explain what you did to get it to work. Resources: 0. Man 1. Google Write up a few sentences for each of the questions. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/5-UpdatingLinuxandPackages.html":{"url":"BuildaLinuxLab/5-UpdatingLinuxandPackages.html","title":"Updating Linux and Packages","keywords":"","body":"Just like on any operating system, one of the first things you should do after installing Ubuntu is to make sure all the software is updated. This minimizes the number of bugs we encounter, as well as helps to patch our computer against vulnerabilities. Make sure to update your Host OS as well, and that you install patches to your Virtualization Tool. Having all of these updated ensures a smooth and secure experience. Sudo and Privilege Before we get into updating things, first we need to talk about privilege. No, not that kind, though it's worth talking about. In this course we will be discussing Linux privileges. By default, Linux only allows certain users the ability to access some files. You will learn more about why and how this is implemented, but for now, just know that the standard user, you, is not allowed to update files controlled by the OS or other users. This is generally so that you don't break anything by accident, but also as a security feature to prevent a malicious user or process from stealing information or breaking things. The command 'sudo', which stands for \"substitute user do\", is used to escalate privileges up to the level of the username specified in the command. 'sudo' defaults to administrator access, which on Linux systems is referred to as \"root\", if no username is specified. (For a fun fact, 'sudo' used to stand for \"superuser do\", but it has over time shifted to substitute user.) A user or process with root access has the ability to read, write, and modify anything on the system. As a best practice, instead of always using root for our everyday activities we log in as a normal user, and only use root privileges when we need to, using 'sudo'. This is referred to as the Principle of Least Privilege, and if you are interested you can learn more about it in our Security course. To run a command with root privileges, all we have to do is put the command 'sudo' in front of the command we want to run. When we do this we will be prompted for the root password, and if we enter it correctly the password will be checked against the correct files and the desired command will be executed with root privs. That was a long winded response, and believe me, I skipped over some detail, but this is what you need to know for now. You'll learn more in the Permissions section. Packages Packages are what Linux OSs (basically all OS, programming languages, etc) use to distribute and maintain software. They are custom file formats that usually contain an archive of compressed files that are used to install, as well as some metadata that describes how to install and what the dependencies are. Dependencies are a list of what other programs a piece of software need to be installed in order for it to run. Developers use packages to build programs that are easy to install and run across many different machines. As long as the package installs itself properly, the program will work! Without package managers, installing things would be very painful, and nobody would use new software. With them... still painful, but at least better. For example, if you are installing an image editing program named Program 1, it might have a single dependency which is named Program 2 that is used to open image files. When Program 1 attempts to install itself from a package, it will check its dependencies and find Program 2, and if Program 2 is not available, it will stop the installation. After you install Program 2, and then rerun the command to install Program 1 and it will succeed. On Ubuntu, the package management system is named DPKG, or Debian Package, as Ubuntu is based on the Debian OS. 'apt' and 'apt-get' are front ends for the DPKG system, and allow command line access to update and install new packages. Ubuntu also has the ability to download .deb files and install them using system tools, either from the command line or the GUI. While there are minor differences between 'apt' and 'apt-get', they do basically the same thing and I am more used to using 'apt-get' and you'll see many more examples of it on the internet so that is what I teach. In addition to the default package management system, there are 3rd party managers for different pieces of software like Python, as well as different file formats that developers can choose to release their software with instead of DPKG. Honestly, it is a bit of a nightmare keeping them all straight, but at least you can usually google the name of the program and the package manager to get troubleshooting directions. Finally, you can compile programs from source using the correct compilation arguments. This is the old school way to do it, but it is much more difficult and is rarely recommended by the developers who release software. Update Packages We will use apt-get because it has slightly more features (and it's what I'm used to). When dealing with packages, 99% of the time we will only need three commands. $ sudo apt-get update As a first note, any time you are working with packages you will want to use sudo in order to ensure you have the permissions to install new packages. This command will use apt-get to update the list of available locations and dependencies for all the repositories and Personal Package Archives (PPAs) that are saved on the computer. This does not update any software, rather it updates the saved locations and version numbers of all the software that is saved on our computer. There's a little more complexity than this, but don't worry about it for now. Run the command now to update. $ sudo apt-get upgrade This command will check the list of packages that you just updated with apt-get update and then download and upgrade any packages on your computer that need upgrading. If you don't run update first, you won't upgrade anything. By running update and then upgrade you will ensure everything on your system is fully up to date, but be warned, it can take a while. This is the format for installing a new program. \"Foobar\" is a programming joke that just means a placeholder word. If you see \"foobar\", \"foo\", or \"bar\" anywhere, it almost always means it's a placeholder for something else. $ sudo apt-get install foobar This command would install the most recently updated version of the program \"foobar\", if the program \"foobar\" existed. Again, always ensure to run update first or you might get an old version. In the next section we will actually use it for real. Continue when all your updates are complete. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"BuildaLinuxLab/6-InstallingPrograms.html":{"url":"BuildaLinuxLab/6-InstallingPrograms.html","title":"Installing Programs","keywords":"","body":"Personalize Now that the VM is yours, it is time to personalize it. Going forward, I strongly recommend that you do everything in your Linux VM. That means your homework, checking your emails, listening to music, anything. The more time spent immersed the better off you will be. Next I am going to have you install programs from a variety of sources. There is nothing in here that is for power users yet, this is just to help you make your VM habitable. Don't worry about typing in your password to install things on Linux. This is normal behavior anytime you use higher level permissions. If you have any problems, ask in #techsupport. Install Some applications Install Gnome Tweak Tool from the command line and do something interesting sudo apt-get install gnome-tweaks Remember this command? As an interesting note, Gnome is the default GUI that comes with the Ubuntu OS, but that was not always the case. If you really wanted to, you could replace the Gnome GUI with a different GUI due to the open source nature of Linux OSs. Install Google Chrome (or another browser) using a .deb file .deb is the file extension for a Debian package, as Ubuntu operates under the Debian system. Any .deb file should work on Ubuntu. If you're looking for a more lightweight browser try Chromium, and if you're into privacy, check out Brave. Both have .deb files Install the art program GIMP via the 3rd party package manager FlatPak and make a meme! There are many other 3rd party package managers, nothing special about FlatPak When you are done making a meme, post your meme in Slack in the channel #course_computing. As you can see, there is some surprising complexity in how we install files on Linux... but let's not worry about that too much yet. Hopefully this section gave you some confidence doing uncomfortable activities. Continue when you are done. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/0-ManPages.html":{"url":"LinuxBasics/0-ManPages.html","title":"ManPages","keywords":"","body":"At one point, this was the first assignment in the course. That's how important I believe man-pages are. I've since moved it back a bit until you have access to a Linux command line so you can see it in all its glory. First, think about a command you want to learn about.... you don't know any yet? Well let's start strong, man is the name of the command that pulls up manpages. So you use man by doing this: $ man [name of program you are interested in] But what should be the first program we check out the man-pages for... oh how about man? $ man man That's meta, man. Always Have a Goal Look at the output of man man (or this online copy of the man-pages if you aren't in a VM ) and write down the first three things you don't understand. Once you have found three things you don't understand: STOP READING! It will only hurt your head, and there is no need to go any further. Remember Rule 3 of the Hacker Attitude, \"Boredom and Drudgery are evil.\"? If you're not getting anything out of something at any point in this course, don't do it, and leave us feedback that we are wasting your time. We mean that. You won't hurt my feelings. The reason I had you write down the first few things you didn't understand is I want to make it clear to you how useless it would be right now for you to dive, unguided into the material. Reading a man-page, with no direction and no firm base to start from is a waste of your time. For the rest of the course, and the rest of the time you do anything on Linux, still can't go wrong to do a quick look at the man-page and get an idea of what programs can do. Don't read them in their entirety or try to memorize the functionality, but if you're having problems, always a good idea to RTFM (or you might get stabbed by your toaster). Assignment Answer in a sentence or two. Questions: What is a man-page? How do I pull up the man-page for the system call \"read\"? What can I learn from man-pages? Resources: https://en.wikipedia.org/wiki/Man_page Answer in the usual format. Please only submit .txt files. No .docx files, no .odt, no .pdfs please! This makes review easier. Use the partner groups I had you make to submit your assignments and get feedback on them, They'll be able to help you with your pre and post-questions. default Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/1-MoreManPages.html":{"url":"LinuxBasics/1-MoreManPages.html","title":"More ManPages","keywords":"","body":"So you've learned a few commands and you generally have an idea how to read manpages, but let's put you over the top. How do we learn about man? Well, man man of course! There is a lot in there, but let's go through it piece by piece. MAN-PAGES(7) Linux Programmer's Manual MAN-PAGES(7) The top line here shows MAN-PAGES(7). What does the 7 mean? Well if we go a little bit further down we can see. Theres a ton more documentation underneath but we are going to ignore it right now because it isn't what we are looking for. We got the documentation guide but shouldn't the man we are looking for be in Section 1, as a user program? Let's try that command again, but instead specify Section 1. $ man 1 man There we go! Alright wow, lot going on there. We see the \"MAN(1)\" at the top, the name, a synopsis section that shows example usages, description, a bunch of usages... Alright that's enough, if we don't need to read the man page for something, don't! Let's look at something a bit more interesting. Use man to find the flag used to make mkdir \"verbose\". $ man mkdir You should see the (1) in the top left so you know it's a command. Verbose is just a fancy word for output more information to STDOUT and STDERR than usual, you'll see it all over the place. For many programs, adding a -v flag will really help with troubleshooting. Remember, if the man page doesn't help, googling the command and the word \"usage\" will usually get you where you need to be. Scroll to the bottom and you will see under \"See Also\" mkdir(2). Go back to the command line with 'q' and check out the man page for the mkdir system call. Don't read it for understanding, just skim to see what this is showing. This task was meant to illustrate how system calls are defined so that software can make directories by using the OS provided API. You don't have to worry about system calls right now, just commands, but keep in mind that is what is going on behind the scenes for all the other software on your computer. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/2-BasicsofNetworking.html":{"url":"LinuxBasics/2-BasicsofNetworking.html","title":"Basics of Networking","keywords":"","body":"Networking is complicated and how it all works is saved for an entirely different course, but for now there are a few main tools you need to learn in order to take your first steps towards becoming a guru. I am going to handwave a bunch of things, just trust me, what I'm handwaving doesn't matter that much for now. This is all part of some kind of plan. IP Addresses and Basic Networking You might have heard the word IP address before, but we aren't going to dive too deep into it yet. Just think of it as the way other computers know who you are, and based off of a complicated routing system, how computers in between you and whatever you are talking to knows how to transport things back and forth. There will be plenty more on this in the Networking Course which you are going to do next anyway, so don't worry about how it works. To find out your IP address, run the command \"ip addr\". This will print out a list of things called interface and some other stuff, don't worry too much. For now, focus on the IP addresses, the items in the form 127.0.0.1, 192.168.20.45, 182.16.10.100, 10.2.5.24 etc.... addresses in that form are known as IPV4 addresses. (There's another format known as IPV6 that looks like 2001:db8::8a2e:370:7334 but we aren't going to worry about them right now) You should only have a few of them, so look for your 127.0.01 address. This is called your localhost, aka, your computer's local IP address. It is completely internal, and all computers have a localhost at 127.0.0.1. This means that you can't talk to someone else's localhost address and it is non-routable. You should have at least one more IP address listed, likely in the format 10.x.x.x, 192.168.x.x, or 172.x.x.x. These address ranges are known as \"local\" addresses. Long story short, there aren't enough IPV4 addresses. If you want to read more about this, the wikipedia article is decent. To get around the lack of IPV4 addresses, most private networks use these local addresses for all the computers on it, so that they don't need to own all the IP address space required for all of their computers (what? people own IP addresses? Yeah it's super complicated, we're gonna ignore that for now) So when you see those local IPV4 addresses, what you are seeing is the IPV4 address your network has assigned to you to use locally (and only locally). Routing How do we connect to the internet then? Well, there's some magic called routing we aren't going to worry about too much for now, other than to be confident that it works. Let's trace our route to google.com to confirm that routing is working properly. In linux, this uses the command traceroute. Windows uses tracert. $ traceroute google.com You should see a nice fancy print out of all the servers you've hopped across, starting with your gateway router and ending with the google.com server. This family of commands is especially useful for troubleshooting networking problems. (For a fun hack, try traceroute bad.horse. Gotta love abusing protocols to do cool things) So what does google see you as when you make a request? I recommend a quick trip to a website to find that out! Click here to find your public IP. As you can see, your public IP is completely different than what your local IP is when you run ip addr. The reason for that is something called NAT, or Network Address Translation which is a method of mapping one IP address to another by modifying packets while they are in transit. It's hella complicated how it works, but what matters to us, the end users, is that our local address is stored by some NAT server which ensures that any responses to traffic from us that leaves our network, comes back to our locally assigned IP. On the other hand, nobody should be able to connect into a box behind NAT because they will not know the local IP address and either way, a local address shouldn't be routed across the internet. So just remember for now, NAT allows connections out and responses back, but does not allow connections in. (Just smile and wave, nobody understands NAT, but we'll go over it a bit more in the Networking Course). How does routing work? How do the packets actually get from Point A to Point B? Patience my friend. Later in the course in the web section we will talk about it. VM Networking So how does this all tie back into practical application? Well your Virtualization Software will have an option to switch your VM between a NAT'd IP address and a Bridged IP address. I don't spend much time on Windows in this course, but run the command ipconfig in your Windows CMD prompt to get your host computer's IP address. Bridged IP addresses are IP addresses assigned by your local router, which will be NAT'd by the router when you try to connect out. NAT'd IP addresses are IP addresses assigned by your virtualization software, which puts that box behind a NAT. This means that if you are NAT'd, another local computer will not be able to connect to you, but if you are Bridged, your IP address will be routable. You're still both behind a router NAT, but it's the same NAT so you'll share the same IP address prefix. Depending on your Virtualization Software, switch between the different networking modes and see how your IP address (and routing) changes. Run the ip addr command to check. If you are having trouble switching, assume that it is because Windows Hyper-V is doing bad things (even if you aren't using it). It's possible to fix Hyper-V issues by \"disable network interfaces hyper-v\" (there's your search term), but it's mostly a pain that pops up every once in a while. VMWare Virtual Box Hyper V Don't try to do the HyperV one, it's a nightmare. Just install VMWare. Over the next few sections, think about how changes in your local address will effect routing. Netcat Netcat is known as the \"Swiss Army Knife\" of networking tools. Whatever you want to do, you can probably do it with netcat. It comes pre-installed on most Linux machines, which makes it a common troubleshooting tool. While there are many features, the most common use is that you can use it to send and receive arbitrary data across a network. The way we send data across a network is with things named \"protocols\". Netcat speaks the TCP and UDP protocols, but that doesn't matter all that much right now. Protocols run everything online, but we are going to save learning how they work for later. Using pipes and redirectors that we learned about in the last lesson, we can choose the input that is sent via the network, as well as what we do with the data once we receive them. On the command line we can use nc as a short name for the netcat program. $ echo 'Hello World' | nc 127.0.0.1 1337 When we run this first commnd, we take the STDOUT of echo and pipe it as the STDIN of netcat. The first argument for netcat is the IP address we want to send it to, and the second number is the port we want to send it to. Netcat will then send 'Hello World' off to the correct location. Networking is hard, but we will skip a lot of the hard stuff for now. At this time, just know that most computers have an IP address and have thousands of ports. If two computers want to pass data over a network, they have to know the correct IP address and port to send data to. In this case, we are using netcat to send 'Hello World' to IP address 127.0.0.1 to port 1337. IP address 127.0.0.1 is often known as localhost, and is our current computer. You can also write that command as: $ echo 'Hello World' | nc localhost 1337 If you noticed, nothing happened, which is kind of expected. How can we see if data was sent without setting up something to listen? Now we get to see what netcat can really do! Open up a new terminal and set up a listener on localhost port 1337 with this command. (As a note, there are multiple versions of netcat, all named the same thing. Sometime they behave differently and have slightly different flags. The following command should work for all versions of netcat.) $ nc -lp 1337 Now you have set up a listener, go and run the first command again from your other terminal to send 'Hello World'. Look at that! You have NETWORKED!!!!! To stop listening, press ctrl-c. That generally closes out or \"interrupts\" most processes in the terminal. Let's talk about what just happened. First, you set up a \"server\", the listener. Then you had the \"client\" send data to the listener. This is about the most basic client-server setup you can get, but the principles remain generally the same all the way up to the complexity of web pages. Send a File For more fun, we can even send files around using redirectors because of how well Linux handles streams. First modify your listener to output to a file using '>'. Then, use cat to read an existing file into a stream and then use '|' to pass it into netcat. Now you should have transported the file into the new location where your listener was pointing! Alright, so that wasn't magic, though it is pretty cool. In the future we will look at this traffic as it moves around the network so you can get a better understanding. For now, just know there are rules that govern exactly how it works and soon you will fully understand it. Rainbow Connection To do something really cool, make a clone of your current virtual machine and run two VMs side by side at once (You'll need at least 4GB of RAM). Once you have them both spun up, run \"ip addr\" to get each box's local IP address. Get the networking going properly that you are able to connect between the two boxes using those netcat tricks. If you are with a friend, get their IP and just try to connect to each other's box, no clones needed! (As a useful hint, you need to be on the same local network to be able to \"route\" to eachother's IP addresses. If you are both behind NAT or host-only it won't work, so I recommend you switch your VM Networking to Bridged and make sure you are on the same WIFI network. You might need some Google but it is pretty cool. If you don't want to do this, or your computer doesn't have the space, don't do it. Just make sure you have an idea of what would be going on. curl There are plenty of tools (like wget which we used earlier in the course) to download a file from the terminal, but I prefer to teach curl as it is able to support the most protocols (and can upload too if you need it). Curl is super useful to quickly grab resources if you have the URL. There are a ton of flags to let you do whatever you need, but don't worry, there are also plenty of great cheat sheets like this one If you do not have curl installed, you will have to install it using apt-get. I think you can do that by yourself now. Most of the time, this is all the command you need to download a file. $ curl -o image.png https://raw.githubusercontent.com/hoppersroppers/hoppersroppers.github.io/master/_layouts/compass.png If you don't have curl on a system, the easiest way to download a file is wget. There are a lot fewer features, but that doesn't mean it won't work. Note the capital O vice lowercase o. $ wget -O image.png https://raw.githubusercontent.com/hoppersroppers/hoppersroppers.github.io/master/_layouts/compass.png See What Is Doing What For something I am going to hand-wave, but at least is very interesting, I'll introduce two commands that show you what is making connections on your computer and tell you basically nothing else about them. They are cool but a bit overkill for what we are doing right now. Before we run them, set up a nc listener and connect to it. After you run the commands, go look for the nc processes... You should be able to find them! $ netstat --inet -ap $ lsof -i For a pro-tip, anytime you want to look like a hacker, run these commands and you'll have a very cool looking display up. Telnet Telnet is an old fashioned protocol that usually provides nice and easy shell access to anyone running a telnet server, which is often unauthenticated. It's a hacker's dream! Too bad you don't see many of them these days, but they are common in CTFs, and on critical infrastructure (jokes?). Here's a fun telnet demo to show what it is capable of: $ telnet towel.blinkenlights.nl Hackers gonna hack. And bored people... well they're gonna bored people. SSH Another very important tool is Secure SHell or SSH. They are basically the secure successor to Telnet for providing remote shells. We won't go into the networking specifics of this yet, but SSH is a networking protocol that allows encrypted access to remote computers. How this works in effect is a remote computer, the SSH server, will listen for an incoming connection. The local computer, which is the client we are trying to SSH from, sends a request via the SSH protocol to log in to the SSH server. If the password supplied is correct, the server will then create a shell on the remote computer and then pass back the stream from that shell to the client. From there, the client who just logged in via SSH is able to have access to the remote computer in an encrypted manner. I hand waved a ton of complexity there, but it doesn't matter yet. We'll spend some more time on this in the networking course, but you honestly don't need to know the specifics, I certainly don't. To SSH, you can either use a password or a key. Most of the time you will have a password, and that is what we will focus on in this course. The networking course will have more info on keys and SSH. To use ssh, simply run the command: ssh username@domain.com. There are plenty more options, but this one will get you through 90% of use cases. Now, let's move on to the next section and use SSH. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/3-HackerEthic.html":{"url":"LinuxBasics/3-HackerEthic.html","title":"Hacker Ethic","keywords":"","body":"Similar to the Hacker Attitude, something named the 'Hacker Ethic' came from the famous book Hackers: Heroes of the Computer Revolution. As defined by the author of the book Steven Levy, the Hacker Ethic can be broken down into a few key words: Sharing Openness Decentralization Free access to computers World Improvement Foremost, upholding democracy and the fundamental laws we live by as a society Explained a little further, the ethic comes out to six key beliefs: Access to computers and anything which might teach you something about the way the world works should be unlimited and total. Always yield to the Hands-On Imperative! All information should be free (A topic of debate, this means free as in free speech, rather than free as in free beer) Mistrust authority, promote decentralization Hackers should be judged by their hacking, not bogus criteria such as degrees, age, race, or position. You can create art and beauty on a computer. The concept of \"hack value\" is doing something that is worth doing because of the \"playful cleverness\" required. Computers can change your life for the better This ethic is meant to be a positive one, designed to guide behavior of a large number of very different people in a positive manner. I can't find anything to disagree with and try to generally follow these rules. As an important note, no one will ever quiz you on the Hacker Ethic or Hacker Attitude, and it isn't like this is common knowledge that people talk about to show off how smart they are. I include this lesson so that you can try to wrap your head around what motivates a great portion of the community and give you time to start thinking about how you feel on these subjects. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/4-LittleBitMoreNetworking.html":{"url":"LinuxBasics/4-LittleBitMoreNetworking.html","title":"Little Bit More Networking","keywords":"","body":"Watch this video on Networking Fundamentals! The whole series is good, but don't get distracted, get back to this. Read this on An Introduction to Networking Terminology, Interfaces, and Protocols . Take time to make sure all of it makes sense, sort of. Don't really stress about it. Then read this on Routing Tables What is an interface? What is IPV4 vs IPV6? What is a MAC address? How do routing tables work? What is a protocol? What are some common protocols? There is no assignment for this section. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/5-OvertheWireBandit04.html":{"url":"LinuxBasics/5-OvertheWireBandit04.html","title":"Over the Wire Bandit 04","keywords":"","body":"You might have heard of Over the Wire before, it is a very famous online wargame. This is a classic set of challenges that every member of our team has fought through, and while it takes some time, you should have had enough experience to figure out what you need to do. It won't be easy, and it might not be the most fun, but completion of this challenge is the single greatest determining factor in whether or now you continue along this journey. This is where you have to grind it out, make things happen, get stuck, learn things, and really spend some quality time with man pages. Use this page to figure out what you need to do for each level: https://overthewire.org/wargames/bandit/bandit0.html Let us know if you get stuck on any challenge for longer than a half hour, we will gladly point you in the right direction. And no cheating! While there are 25 Bandit levels, at this time we only expect you to be able to complete 0-4. You should know everything in here, but it will be a bit hard. SSH into : ssh bandit.labs.overthewire.org -p 2220 -l bandit0 With the password bandit0 If you're having trouble figuring out what you should do for level 0, check out this video. I'd make my own, but I hate making videos. If you ever get stuck on anything for more than a half hour, message us in #techsupport and we will help you out! Don't worry, I have no problems giving you very specific instructions to get to the next stage. If your googling keeps popping up Bandit walkthroughs instead of references, use the search operator -\"bandit\" to clean up the search results. Good luck!!!! We are not going to let you end your journey here!!! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/6-StartinganInfosecCareer.html":{"url":"LinuxBasics/6-StartinganInfosecCareer.html","title":"Starting an Infosec Career","keywords":"","body":"There are hundreds, maybe even thousands of resources on the subject of starting an infosec career. Hell, even I wrote one. There are even more on what it takes to be a hacker, how to get a job, what to learn, where to learn it, how to learn it.... In my opinion, if a new student is pointed at a list of resources and told they should be able to teach themselves, that is basically the same as telling them to go Google it. There are arguments in defense of finding the answers yourself, and that is why this course does not hold your hand the entire time. What it does do is point at exactly where your next step in the journey should go and give you the best resources possible. Because reading things makes us feel good and we learn things, if you are going to read anything, my recommendation is you read this series of essays by Lesley Carhart. https://tisiphone.net/2015/10/12/starting-an-infosec-career-the-megamix-chapters-1-3?roppers/. If you want to read a second article, here is one from Daniel Miessler. https://danielmiessler.com/blog/build-successful-infosec-career/?roppers Now reading those feels good, but listen to me, take everything that they say to heart, and don't look for any more articles on starting an infosec career. When one pops up in your browser, ignore it. When someone posts a list of resources, ignore it. As much fun as they are to read and bookmark, they won't improve your ability. What will improve your ability is to follow this course and trust that the curriculum will result in the most efficient education possible. Once you're done with this course, read whatever you want. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/7-MidChapterSurvey4.html":{"url":"LinuxBasics/7-MidChapterSurvey4.html","title":"MidChapter Survey 4","keywords":"","body":"On a scale of 0 to 10, how likely is it that you would recommend this section to a friend or colleague? Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/8-MaintainingMotivation.html":{"url":"LinuxBasics/8-MaintainingMotivation.html","title":"Maintaining Motivation","keywords":"","body":"Read this: https://jamesclear.com/motivation This section is a work in progress, but it breaks down to a few key ideas: Motivation is about building routine and taking the mental effort out of doing the work, and making it mentally straining to not do the work. This is why building habits is so important. There are a lot of things that feel like you are working, but aren't really working Watching video courses because you don't have the mental capacity right now (guilty!) Scrolling Twitter (guilty!) Gathering resources and skimming papers for things to read more later (guiltyyyyyyy!!) Schedule your motivation and do not allow any distractions to occur during this time. Alright now, time to keep going. Only thing that separates you from your previous self is how much work you are willing to put in. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/9-TextFu.html":{"url":"LinuxBasics/9-TextFu.html","title":"TextFu","keywords":"","body":"You've already done a little pipelining text-fu in the last section, so let's learn a few more commands that can be used to view and modify text streams. I'll give you some info about the commands, but in general, any time you want to learn more about these tools, just use the man pages. Let's start with viewing, because that is pretty straight forward. Viewing Streams In addition to the wonderful cat we also have: head head will print the top few lines of a larger file tail tail will print the last few lines of a file less less will bring you to the top of a file and allow you to scroll or search through it more exists but is \"deprecated\", which means you shouldn't use it but it probably still sort of works For a good sized file to test these on use /var/log/syslog as your target. Don't worry too much about what is going on with the file path you just chose, we'll talk about it more in the File Systems section. The takeaway here is knowing which to use when looking at a large file. If you try to cat your syslog you will see something I call runaway prints and it will fill up your terminal. Type clear to clear it on out. If you find that you've broken your terminal and things aren't displaying properly, type reset. String Modification Let's learn some more tools to work with files. Hopefully you still have your animals file from earlier, otherwise make it again. $ echo cat dog sheep cow dog cat ``> animals$ echo cat dog sheep cow dog cat >> animals$ echo cats >> animals I'll give you some commands, play around with them and read the manpages to get an idea what else they can do besides the basic functionality. cut Man Page Description: Remove sections from each line of files. Print selected parts of lines from each FILE to standard output. The command cut does basically what you would expect it to, cut out parts of text. The way it works is we set a delimiter (-d) based off of what we want to split the file on. In this case, we use spaces, represented by \" \". \"-f\" is used to describe what columns we want, numbered from the delimiter. We can also represent \"1,2\" as \"1-2\". Play around with cut to see what else you can do. $ cat animals | cut -d \" \" -f 1,2 awk Man Page Description: The awk utility shall execute programs written in the awk programming language, which is specialized for textual data manipulation. An awk program is a sequence of patterns and corresponding actions. When input is read that matches a pattern, the action associated with that pattern is carried out. The command awk is similar to cut, but assumes the delimiter is a space. using the brackets (your first bash script! Don't forget there is most of a programming language hidden in bash) we can choose to print however many items we want. Don't worry too much about how the variables (preceded by \"$\"\" ) work, or how the script works, just send itttt. $ cat animals | awk '{print $1\" \"$2\" \"$3}' sed Man Page Description: Sed is a stream editor. A stream editor is used to perform basic text transformations on an input stream (a file or input from a pipeline). The command sed lets us do fancy targeted replacements of words using the format shown below. Play around with changing the words in the \"/\" to match different things. $ cat animals | awk '{print $1\" \"$2\" \"$3}' | sed 's/dog/anon/' tr Man Page Description: Translate, squeeze, and/or delete characters from standard input, writing to standard output. The command tr is an interesting one and allows you to do a direct swap of one character, or a range of characters to another. This is very useful for things like removing junk text or new lines (represented by \"\\n\") $ cat animals | awk '{print $1\" \"$2\" \"$3}' | tr 'd' 'a' $ cat animals | awk '{print $1\" \"$2\" \"$3}' | tr 'do' 'pi' grep Man Page Description: grep searches the named input FILEs (or standard input if no files are named, or if a single hyphen-minus (-) is given as file name) for lines containing a match to the given PATTERN. By default, grep prints the matching lines. The ole' grep is crazy complicated but very powerful. One of my friends once wrote a 30 page book on how to use it effectively, but umm.... that's a little more than we need. Good for you though Danny boy. 95% of the time we need to use grep all we are using it for is to search for a string and then print the line the string is in to STDOUT. Combined with the many flags it has and ability to do complex searches, and piped into other commands it is exceptionally powerful. Check the manpage to see some of its other functionality. $ cat animals | grep \"dog\" Bringing it all Together Now on the /var/sys/log we looked at earlier, we can bring it all together. Let's say I hypothetically wanted to send you a copy of my /var/sys/log related to an issue about something named \"systemd\", but I didn't want you to know my username. What if we combined a bunch of these tools together to go through our logs and anonymize them for us. In this case I am using \"dennis\" in the script for name of the user I want to replace with \"anon\". If you don't know your username, run whoami, to return the current user and put it into the script. $ cat /var/log/syslog | grep \"systemd\" | awk '{print $3\" \"$4\" \"$5\" \" $10\" \"$11\" \" $12\" \"$13\" \"$14}' | sed 's/dennis/anon/' Think about what just happened. For your assignment, write out what STDIN, STDOUT, and STDERR are and what is happening for each of the commands. (Hint: Don't forget about https://explainshell.com/, but be sure to fill in more of your answer using the man pages) Answer in the usual format. Questions: 1. grep 2. awk 3. sed Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/10-TextEditors.html":{"url":"LinuxBasics/10-TextEditors.html","title":"Text Editors","keywords":"","body":"When we write programs, edit config files, or even take notes to study later, we will do that with a text editor. Echoing and cating text only gets you so far. There are hundreds of text editors, and much like programming languages, each has its own tradeoffs. Some are simple and have a GUI, some are terminal only and are incredibly complex. Many have entire programming languages built into them, or are even shells themselves, capable of executing programs. As a general rule, use what works for you and don't seek out complexity for complexities sake. I used to use the most complicated text editor I could so I looked cool, now I use the simplest ones I can for the job at hand. Ubuntu comes with a few text editors installed initially, but the ones we will focus on are gedit and vi/vim. gedit To open Gedit, simply type $ gedit & in the terminal, or open it from the GUI. gedit is a GUI application, and gives you a nice window, normal use of your mouse, copy/paste, and all the normal things you expect from a text editor, similar to Notepad on Windows. I use it all the time to display information and make notes, but I also program in it every once in a while. Many people who like to think they are badasses think they are too cool for gedit. Those people are silly and you should ignore anyone who thinks that text editor choice has anything to do with how good of a hacker you are. Terminal-Based Text Editors gedit is a good option if you are on an Ubuntu desktop, but many times you just won't have a GUI at all. If you are SSH'd into a box, or using a server build, you will have to learn how to use a terminal text editor. nano The default editor that comes with most Linux distros is named nano. It's basic, it's functional, and it gets the job done. To open it, type nano and just start working. The keys to save and do other functionality are displayed at the bottom, no tutorial needed. It's as easy as it gets, it works great, and it's basically everywhere. With that said, it doesn't really have any advanced features, so while it's perfect for a minimal experience, if you're going to be coding you likely want something more advanced (aka hardcore and hackerish). vi/vim The other editor that comes with all Ubuntu distros is named vi. It has a more modern, more advanced successor named vim. I think it is better to initially learn vi/vim because it has more market share. Most prominently, I often find myself using vi on computers I do not have the ability to install new programs on. If I don't have the permissions to sudo apt-get install vim or anything else, I am going to be using vi, so it's easier for me to just use that for my terminal text-editing needs. Because vi/vim are always available, I believe it is the best family of editors to learn initially. You can always lean on nano, but vi/vim gets the job done, better. The final major terminal-based text editors is named emacs. Don't worry about learning it, but it is good to know they exist. Notably, there was once something named \"The Editor Wars\", when nerds argued with each other if emacs or vim was better. Nobody won, everyone wasted time, and if you hear anybody today talking about why one is better than the other, ignore them. Even me. What makes vi/vim/emacs/other terminal-based text editors special is their extensibility and keyboard based shortcuts. By offering powerful commands inside of the text editor, a programmer can speed up their navigation of a code base and type faster. vi and vim can be considered roughly equivalent when it comes to their core shortcuts. To get an idea of how to work with vim, install it and play around with the first few chapters of the built in tutorial by running the command vimtutor from the terminal. Hint: To close out of vim, press escape key and type \":q\". To save, escape key then type \":w\". Without that knowledge it can get a bit awkward for beginners. However, the speed increase of mastering a cool text-editor is not actually that much. Even if we increase speed of typing/navigation by 10%, it won't actually make us a better programmer. Luckily, there is a form of text-editor that provides that benefit to us that we will talk more about in the programming section. For now, vim should get us what we need. Play around with \"vimtutor\" and learn a few commands. Print out a vim cheatsheet or put it on your desktop so that you can constantly reference it. The more you use it, the easier it will be to remember. For your assignment, print out a cheatsheet or put it in your desktop if you don't have a printer. Believe me, this is for your own good. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/11-Search.html":{"url":"LinuxBasics/11-Search.html","title":"Search","keywords":"","body":"More Grep We already played with grep a bit, let's do a little bit more. First, let's learn what grep stands for: Global Regular Expression Print. $ cat animals | grep \"dog\" $ grep \"dog\" animals Both of those do the same thing. We can also search an entire directory by using the \"*\" symbol, often known as a wildcard. This wildcard will open every file in a directory. $ grep \"dog\" * As a note, you can also cat * in case you ever want to print every file in a directory. Many other commands use the wildcard operator. If you only want to know which files in a directory have the target word, use \"-l\". $ grep -l \"dog\" * If you want to know the file name and line number, use \"-n\". $ grep -n \"dog\" * If you only want to see the lines in the file which don't have the term you are greping for, use \"-v\". $ grep -v \"dog\" animals This defaults to showing line numbers and file names, so if you only want to see the filenames, use \"-l\". $ grep -l \"dog\" animals Play around with a few of the grep settings to see what else is possible, but don't worry about memorizing them, stick to cheatsheets. And as always, the manpages are your best friend! find Alright, last command for the search section! While grep cared about searching through files, find only cares about file information! Here are some example uses of find. There are a ton of flags for this, so use man anytime you need to do look for something you don't know the flags for $ find directoryName -name secret > find all files named secret in a folder named directoryName $ find directoryName -type f -name \"*.txt\" > find all .txt files. Note the \"*\" wildcard $ find directoryName -type f -perm 0777 -print > find all files with the permission 0777. Don't worry too much about permissions yet. $ find directoryName -type f -name \".*\" > find all secret files! The \".\" in front of the filename hides it from a standard ls. $ find / -user dennis > find all files from the root directory owned by the user dennis > remember that / by itself searches from root (which is a whole lot of searching, so it takes a few minutes) while ./ only searches from current directory. Looks similar but very different results. $ find / -size 50M > find all files from root that are 50MB $ find / -mtime 5 > find all files modified in the last 5 days. Kind of useful from a forensics standpoint, though timestamps are unreliable! This ain't everything but should be enough to help. Assignment Questions: 1. Write a command that will find all .html files on a computer that are 12 bytes in size, owned by \"jake\". * You can make an example file by putting the contents \"is this html\" into a file and saving it as a .html file. * However, getting the owner to be named Jake would require you to create a new user on your system and that is a bit of work * I recommend you just write one that will find ones owned by you, and then for your answer, submit the \"Jake\" version. 2. Write a command that finds any \"hidden\" (starts with . ) file in your user home folder. Resources: 0. Google Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/12-Regex.html":{"url":"LinuxBasics/12-Regex.html","title":"Regex","keywords":"","body":"So far I've only shown you the exact match operator for grep which uses parentheses, but grep has the ability to do many other forms of pattern matching described in the manpage. One of the most useful is regex. Regex stands for \"Regular Expression\" (hey remember that from the grep acronym?) Regular expressions are a technical way to define a particular search pattern, and grep is built around them. As an aside, Regex is everywhere in computing. You can use it for HTML input validation, you can use it to search for data in log files, basically anytime that a standard exact string search won't help. It is implemented in most text editors and programming languages. Regex is very complicated, very powerful, and basically a programming language in itself. To make things even more complicated, there are multiple competing regex syntaxes, all of which are slightly different. Any time you find yourself doing regex, make sure to check which standard is being complied with and modify your regex accordingly. Posix and Perl standards, despite both starting with p are NOT the same! I'd love to try and teach you, but learning regex is something I don't wish on anyone, and more importantly, you don't need to learn regex... or even understand it. As a famous hacker once said: \"Some people, when confronted with a problem, think \"I know, I'll use regular expressions.\" Now they have two problems. We will go over some quick examples, but don't plan on leaving this section an expert on Regex, more just be confident you can deal with it if you need to. You won't use it often enough to justify the headache of \"learning\" it, I promise. First, read this blog on 'The Absolute Bare Minimum Every Programmer Should Know about Regular Expressions'. It is considered by many to be the best regex intro on the internet. Example 1: Cheatsheet Now that you've read that and have a vibe, let's get into it. Here is a cheatsheet (https://www.rexegg.com/regex-quickstart.html) which should give you everything you usually need to figure out Regex stuff. The hard part is tying all the things on this cheatsheet together. Look through these examples from https://cs.lmu.edu/~ray/notes/regex/ to get an idea of how regex works: gr[ae]y = contains {gray, grey} b[aeiou]bble = contains {babble, bebble, bibble, bobble, bubble} [b-chm-pP]at|ot = contains {bat, cat, hat, mat, nat, oat, pat, Pat, ot} z{3,6} = contains {zzz, zzzz, zzzzz, zzzzzz} z{3,} = contains {zzz, zzzz, zzzzz, ...} \\d = contains {0,1,2,3,4,5,6,7,8,9} \\d+(.\\d\\d)? = contains a positive integer or a floating point number with exactly two characters after the decimal point. 1\\d{10} = contains an 11-digit string starting with a 1 ^dog = begins with \"dog\" dog$ = ends with \"dog\" ^dog$ = is exactly \"dog\" Now, if we were going to write a regex to find all matches that started with a number, had a space, a 3 letter word, and ended with another number, we can try to write that out. Starting with \"a number\": \\d Then \"a space\" \\s Then, \"a 3 letter word\": \\w{3} Finally, \"ends with another number\": \\d$ To bring it all together, the regex would be \"\\d\\s\\w{3}\\d$\". But how do we know we did it right? Example 2: Regex101 You know to use the cheatsheet, but how do you nail down your Regex to be sure you are getting all the results? Anytime you need to do something complicated, pull up a helpful site like this Regex tester (https://regex101.com/) and get your regex query working on some test data. For the query you just wrote, open up Regex101 and enter it into the top line. Then type out a couple of examples of strings you want the regex to match and not match, for example: 3 dfs2 3ddd3 1 d3d 2 3ed3 a aaa1 423aa2 When you enter them into the tester you will see which ones work and which don't, which will allow you to edit as required. There is even a helpful Explanation and Quick Reference section to help you write even more complicated queries. Example 3: Google With the cheatsheet and a Regex tester, you've got most of what you need. In addition, I highly recommend Google and specifically Stack Overflow results for regex help, very often someone else has already done 75% of what you are trying to accomplish. Then you can take that result, put it into the Regex tester, and fiddle away until it works. Again, not trying to make you an expert, just good enough. For example, what if someone tells you to write a regex to look for email addresses? Well... * First we think letters and numbers, separated by an @ sign, with a domain, a period, and then the tld at the end... * But what about all the other symbols? Turns out most symbols work in the name too \"!#$%&'*+-/=?^_`{|}~\" (though you will mostly only see '-'). * And then also '-' are allowed in domains, so those can be in the back half as well. So these are all valid: very.common@example.com \"very.(),:;\\<>[]\\\".VERY.\\\"very@\\ \\\"very\\\".unusual\"@strange.example.com admin@mailserver1 How do we solve this seemingly difficult task?!? Read the email RFC? Wikipedia? How about google for a regex that matches emails? https://stackoverflow.com/questions/201323/how-to-validate-an-email-address-using-a-regular-expression Hell to the yeah. Don't worry, this shouldn't have made sense, and you should feel like you don't understand regex at all. That is perfectly normal. Struggle through this assignment using the tools and tips I have given you, and then move on with your life. Assignment Make sure you know what type of Regex standard you are using!!!! If it seems like some options don't exist, you might be crossing syntaxes/interpreters! Questions: Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/13-WhySecurity.html":{"url":"LinuxBasics/13-WhySecurity.html","title":"Why Security","keywords":"","body":"Computer security is the shield of the modern age. Without the constant battle on the frontlines between the people who want to see technology used for good and the people who want to use it for their own gain, or worse, to limit the rights and freedoms of others, the progress that occurs in the real world because of technology would be dramatically slowed. Security allows trust in technology, which leads to adoption, which leads to progress in one direction or another. The more people able to help out with that fight, the faster we can move as a society, and less things will get broken and less people will be hurt on the way. That's why this site exists, and hopefully, if you're here for the right reasons, you'll be able to jump into the fight with the tools you need to succeed. This course is designed to give you the mindset and fundamental skills necessary to be successful in the information security field. If you already have some experience - great! But we do not to assume any prior knowledge of security or even information technology in general. At the end of this, you may not be a guru (reminder: nobody knows everything), but you should have the mental models and base knowledge to use the Linux operating system, install new programs, and be equipped to find and understand the information you need to learn even more. While I have tried to do everything in my ability to make this course self-guided, there are hundreds of places where a questioning attitude will identify clear shortfalls in the content. Some of these are intentional, most of them are not. Your questions and feedback will guide the development of this course so that it can become the best resource possible. Surrounding this site is a community to help you and provide guidance as you move along. This community grows with each student who signs up, and our mentors will be there every step of the way to answer questions, explain difficult concepts, and talk about just about anything to help you along the way. Make sure to take full advantage of Slack so that we can all be part of this together. This entire following Mindset section is optional, click through it if you want to jump right into some Linux stuff, but I think it's worth at least reading through to get an idea of things. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/14-OvertheWireBandit59.html":{"url":"LinuxBasics/14-OvertheWireBandit59.html","title":"Over the Wire Bandit 59","keywords":"","body":"Back to OverTheWire again! You finished the first five levels, time to go back for 5-9! Pay attention to the \"Commands you might need to solve this level\", but remember, you won't need all of them! https://overthewire.org/wargames/bandit/bandit6.html SSH into : ssh bandit.labs.overthewire.org -p 2220 -l bandit5 With the password: lrIWWI6bB37kxfiCQZqUdOIYfr6eEeqR If you ever get stuck on anything for more than a half hour, message us in #techsupport and we will help you out! Don't worry, I have no problems giving you very specific instructions to get to the next stage. If your googling keeps popping up Bandit walkthroughs instead of references, use the search operator -\"bandit\" to clean up the search results. Good luck!!!! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/15-UsefulLinuxTips.html":{"url":"LinuxBasics/15-UsefulLinuxTips.html","title":"Useful Linux Tips","keywords":"","body":"There are a ton of commands out there to make you more efficient on the command line, but let's highlight some of the best right now! Tab Autocomplete I mentioned it before, but I need to mention it again. Hit the tab key to autocomplete words/paths/anything and save yourself time. Double tap it to get a listing of possible options. cd We all know cd, but did you know about cd ~ which takes you to your home directory, and cd - which takes you back to the directory prior. Do some morphing around your filesystem and use cd tricks to navigate. Check out what happens if you just type cd with no arguments. History You can look at your most recent command history using the command history, and combining that with grep you can pipe the two together to search your most recent commands. But even easier than that is typing ctrl-r, which kicks off a search in your history for you. Line Navigation If you have a super long command and don't want to arrow through the whole thing, you can use \"home\" and \"end\" keys on your keyboard. Even more efficiently than that though, you can ctrl-a and ctrl-e to zoom to the front and back. Reuse Commands Ran a command and forgot to use sudo? Use the \"!!\" operator to run the same command again, and sudo !!. If you want to run the most recent of a certain command, use the single \"!\" operator and the command name, such as !ls, which will run the most recently executed ls command. Much easier than pressing the up arrow until you find what you are looking for. Kill Processes If something is running, ctrl-c should do the trick if you are in the same window as it. If not, ctrl-x is a great standby. You'll learn more about killing processes in the next section. New Terminal In Ubuntu, ctrl-shift-t should pop open a new terminal for you to hack in. If you are already in a terminal, it should pop up a new tab. To switch between these, ctrl-pagedown or ctrl-pageup. To open a new window, ctrl-shift-n should open a new terminal window. With that said, these are very OS specific and might not be the same for you. If that is the case, google for your operating system terminal keyboard shortcuts. Of course, there are so many of these and you can always add more, but this is enough to get the most bang for your (free) buck. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"LinuxBasics/17-JoinOurCTFTeam.html":{"url":"LinuxBasics/17-JoinOurCTFTeam.html","title":"Join Our CTF Team","keywords":"","body":"You've made it far enough into our Fundamentals course that you are now formally invited to the Roppers CTF team! We are named Hopper's Roppers and are a small crew of hackers who are trying to get better and support each other. This is a very informal thing, so don't worry about taking on a commitment. We try to play every weekend, so if the competition is on CTF Time, anyone can sound the call to arms and see who they can get to sign up. There is no pressure to be there every weekend, or even every 6 months, just show up when you can and contribute what you can. Everyone can help! Request to join our team here! https://www.roppers.org/pages/ctf-team In our Slack, check out the #ctftime channel to join the party. Once you finish this course, check out our CTF course so you can get up to speed quickly! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/0-Abstraction.html":{"url":"Hardware/0-Abstraction.html","title":"Abstraction","keywords":"","body":"We have learned about learning and the hacker mindset, and have begun to learn about Linux and set up our new virtual machine. You finished Bandit, and should feel fairly comfortable reading something technical, taking that new information, and then immediately applying it to solve a problem. But now we are at the most important and difficult part of the course, how computers work. Without a general understanding of how computers work from a fundamental level, you will not have the low-level knowledge required to understand things as they occur. As you read a news article, watch a presentation, or find a new CTF problem, you need the ability to recognize patterns and have the baseline knowledge required to immediately know what is going on. That doesn't mean you will understand everything, the point is to build your baseline so that you can constantly have a wide breadth of knowledge to draw from. Depth of knowledge will be learned in follow on courses and your own personal path. With a strong base, you will minimize the time you spend backtracking and relearning things, as well as minimize the time required to learn new concepts. Right now, this is your time to rabbit hole and spend some time so you know enough information to move forward and not worry about having to learn fundamental concepts as you go. We are about to learn about hardware, which is truly where things get complicated. As the operating system abstracts away a lot of complexity, hardware abstracts away significantly more. The things that occur deep down in CPUs and in memory are truly only understood by .01% of people who do security as a job. Even deeper, the CPU abstracts away the activities that occur on the actual chip. Deeper than that, the chip abstracts away from us needing to understand what is happening in the individual transistors. You can go your entire career and never have to look at memory. Most people never have a need to. So please, believe me when I tell you, there is no need for you to understand anything in this chapter. Know that it exists, know that there are entire fields of study contained in here, and if you were taking this at a university it would be about 2 years of study. We're going to fly through it in a few modules. Consider this training for awareness, not understanding. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/1-BitsandBinary.html":{"url":"Hardware/1-BitsandBinary.html","title":"Bits and Binary","keywords":"","body":" You might have seen bits or binary or 01100010 01101001 01101110 01100001 01110010 01111001 before and got a little intimidated... but now it's time to double down and learn what bits are. In the process of learning bits, you will learn binary. Once you learn binary, you're a computer. Ipso facto, this is your last chance to stop before becoming a computer. Binary Basics I'm going to not make my own stuff here and recommend that you use this tutorial, it is fantastic and SparkFun is a great company. Work through this tutorial: https://learn.sparkfun.com/tutorials/binary Once you are done with that you're ready for what comes next. You definitely don't need to memorize binary/ASCII (or any other) conversions, just use a cheatsheet like this one: Character Conversion Cheatsheet. Remember, you don't need to memorize any of this stuff. If you are at a computer, you have access to the resources you need to just look it up every time. Assignment What is ASCII? What is binary? How many bits are used for each character in ASCII? \"01101000 01100101 01101100 01101100 01101111 00100001\" is in binary. Convert it back to ASCII. Do it by hand using the chart. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/2-ComputersareDeterministic.html":{"url":"Hardware/2-ComputersareDeterministic.html","title":"Computers are Deterministic","keywords":"","body":"All that I want you to take away from the next few sections is that computers are, by definition not random, and they are not magic. There are some very powerful applications of physics, hidden under pieces of engineering, which themselves are hidden under layers and layers of computer science, but there is no magic. We do not need to understand physics to understand the software. What we do need to understand is that computers are based on the laws of physics, and as a result, the hardware is meant to be deterministic. Deterministic means that given the same inputs, there should be the same outputs. To understand this, we work from the ground up. If electrons follow the laws of physics every time (which they should), the hardware will work the same every time. (Basically, the only exceptions to this are cosmic rays and crazy hardware faults). If the hardware works the same way every time, the software on top will run the same way every time. If you ensure that your inputs remain the same, your output will be the same. This means that we can take the same data, same configuration, and run test cases, and everything will come out the same way every time. To put it simply, there is an expected result and anything deviating from that is correctable. Randomness Software and hardware can be made non-deterministic by introducing randomness. Randomness is an entire field of Computer Science based around the problem of providing a random number to software. By adding a random number generator, any code that runs after or on top of that non-deterministic process will be similarly non-deterministic. A common topic in Computer Science is the difference between true random and pseudo-random number generators. The most common of the two is pseudo-random number generators (PRNGs), which use software and a \"seed\" to generate a random number. Seeds are fairly easy to predict, which means that because the PRNG is deterministic if we can predict the inputs we can predict the outputs. For nearly all applications, this is good enough, but for some higher-stakes applications, especially cryptography, we don't want there to be any chance someone can predict our seed. For those higher stakes scenarios, sometimes a true random number generator is required. These TRNGs use something like radioactivity, atmospheric noise, or a video of a bunch of lava lamps to create a truly random seed as input. These TRNGs are considered non-deterministic, because it is basically impossible to ever provide the same input and get the same output ever again so they are considered safe to use. Another form of TRNGs is a computer chip known as a Hardware RNG, which, develops an input that is, based on known laws of physics, impossible to predict. This makes the output perfectly unpredictable and can be trusted to be truly random. Overall, randomness is something we control because we choose to put it into our software or hardware. Once we introduce randomness, we make our programs harder to control and troubleshoot. Don't worry too much about randomness, you very rarely need to do anything with it, which means that you can rely on your computers being deterministic. Leave randomness to the Computer Science PHDs and get on with the rest of your life. Why this Matters This idea of computers being deterministic is very powerful. It means that computers are not magic. It means that because they do the same thing every time, we should be able to troubleshoot any problems when they occur by running the process again and seeing where the error occurs. If we are on the same hardware, with the same OS, we can expect the software to run the exact same way. We find where the error (randomness) occurs, correct it, and now the process will run normally. This idea of determinism is critical to seeing computers as something that can be tamed, controlled, and understood. Computers want to work. We don't need to understand the physics or the hardware, we just need to know it is a constant. It has been abstracted away. We need to understand the OS, and how our interactions with the OS modify it, but we don't need to understand any deeper than that unless we want to. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/3-DigitalLogic.html":{"url":"Hardware/3-DigitalLogic.html","title":"Digital Logic","keywords":"","body":"The coolest part of digital logic is that starting from the absolute smallest pieces of circuitry we are able to build anything. From a single gate, we can build complex logic, and from that complex logic, we can structure them together to create the ability to process programs. This is the fundamentals basis of computing. Skim these for a better appreciation... but don't read the whole thing. They're just too long. Just read enough to answer these questions. This is literally entire fields of science and engineering. We get to be abstracted away from them, so let's not worry too much beyond trivia. Digital logic: https://www.explainthatstuff.com/logicgates.html And this: https://learn.sparkfun.com/tutorials/digital-logic How long is a bit? A nibble? A byte? A megabyte? What is a bitwise operator? How do they work? What is a bit shift? How does that work? Explain how digital logic is an essential part of computing. What are logic gates? How do logic gates relate to bitwise operators? Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/4-FetchDecodeExecute.html":{"url":"Hardware/4-FetchDecodeExecute.html","title":"Fetch Decode Execute","keywords":"","body":"Well, we learned what these nand gates and xor is in the last section ... sort of. To oversimplify things, because we can build any amount of logic with them if we arrange it properly, we can start building more and more complicated things, like an entire CPU. We'll handwave the steps in between nand gates and a CPU (I wrote all the code for that once, it was miserable and I didn't learn anything useful, so I'll spare you the details) so let's just jump to the idea that CPUs exist and we want to know how they run programs. You might have heard of the fetch-decode-execute cycle before, which is the basic operation of a CPU. Here is a solid video that will be a placeholder for me before I make a video on the cycle. This part is very complicated and likely will take some thought and maybe drawing a diagram for yourself. Don't be afraid to google for more resources. Assignment: Describe the fetch-decode-execute cycle in words, explaining what all components and registers are doing. Keep it short, but include all the detail needed for you to draw it out and explain to someone. Ensure to include Pre-Questions and Post-Questions in the usual form. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/5-MachineCodeandAssemblyCode.html":{"url":"Hardware/5-MachineCodeandAssemblyCode.html","title":"Machine Code and Assembly","keywords":"","body":"In order to be executed on a CPU, code must be written in a way that is understood by the CPU. This is called 'Machine Code' and consists of 1s and 0s. As a note, there are various families of CPU \"architectures\" which require different machine codes to operate properly. Don't worry about this now. Humans don't like 1s and 0s as much as computers so we prefer to abstract ourselves away from the bits as far as possible. We do this what are called \"assembly\" languages, which is a defined syntax of instructions that map desired outcomes to the binary machine code the CPUs run off of. An assembler is a piece of code written for a specific type of CPU that does a 1 for 1 translation of assembly code into binary that can be executed. I like this video: Assemblers do a 1 for 1 translation from assembly to binary, but what if we are looking for something that can optimize or simplify the work needed to be done by the programmer? Basically, programmers don't want to write assembly all day if they can write in a higher-level language that abstracts away even more of the complexity involved with dealing with CPUs. To do that we would need something called a \"compiler\". A compiler is a computer program that translates computer code written in one programming language (the source language) into another programming language (the target language), almost always assembly. This allows the programmer to write in a human-friendly language like Python, C, or Java, and then convert it to assembly to run. This saves huge amounts of time and allows developers to spend more time doing and less time working. Don't worry too much about how all this works, just understand that it does. It's a bit more advanced than we need, I just want you to be aware of it. As an example, here is a simple program that prints out \"hello, world\" in C, assembly, and machine code. C #include int main(void) { printf(\"hello, world\\n\"); } Assembly global _main extern _printf section .text _main: push message call _printf add esp, 4 ret message: db 'Hello, World', 10, 0 Machine Code b8 21 0a 00 00 a3 0c 10 00 06 b8 6f 72 6c 64 a3 08 10 00 06 b8 6f 2c 20 57 a3 04 10 00 06 b8 48 65 6c 6c a3 00 10 00 06 b9 00 10 00 06 ba 10 00 00 00 bb 01 00 00 00 b8 04 00 00 00 cd 80 b8 01 00 00 00 cd 80 We are all agreed we would prefer to write in C and not machine code, right? Read this about our namesake Grace Hopper and the first compiler: Then watch this: Some day, you might write a compiler so all of the things you just learned about makes more sense to you. Or you can not do that. You don't get as much out of it as people say you would. What we just went over was just the absolute basics of computer hardware and logic. I did not spend any time on machine code, assembly or memory, and you WILL get destroyed by it the first time you see it. My recommendation, avoid anything involving machine or assembly code until after you have spent some dedicated time on the subject. Most people can go their entire careers in security without having to touch assembly. That is a good thing. The only people who really have to deal with this bullshit are reverse engineers, exploit developers, and a few other specific jobs done by people who hate themselves. To translate this, don't try to jump into any Reverse Engineering problems, for now. Take our Fundamentals of Reverse Engineering course when you feel the urge, but for now, just move on. Assignment: Describe machine code and assembly. What was Grace Hopper's primary contribution to computing? Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/6-HardwareHistory.html":{"url":"Hardware/6-HardwareHistory.html","title":"Hardware History","keywords":"","body":" History of Computers Read this: https://www.explainthatstuff.com/historyofcomputers.html Don't be afraid to rabbit hole but remember, this is all trivia and it's not like anyone will be quizzing you on this. It's just good to know. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/7-ModernHardware.html":{"url":"Hardware/7-ModernHardware.html","title":"Modern Hardware","keywords":"","body":"We have come a long way from looms, transistor tubes, and giant building sized calculators. Explain all these modern computer components things. Put it in a text file. Motherboard PCI Slot CPU Why is a fan needed? RAM Hard Drive Optical Hard Drive Solid State Hard Drive Graphics Card Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"Hardware/8-HexandMore.html":{"url":"Hardware/8-HexandMore.html","title":"Hex and More","keywords":"","body":"We've talked about enough hardware, but let's go back to the people side of computing. All things considered, you can avoid binary and worrying about CPU stuff most of the time, so let's not focus on them too hard or be too freaked out it is really complicated. If your job is going to require that, you can get good at it.. otherwise... move on. You've gotten a taste of binary, let's talk about non-binary representation. 1s and 0s really are hard to read, so luckily we have something a bit more 68756d616e207265616461626c65... sorry, human readable. Hexadecimal, base 16, hex, whatever you want to call it, will become a language that you see constantly during your technical journey. Being comfortable working with hex is one of the skills that will help you stand out. From the same site as the binary tutorial (gee, sure hope you liked it) we have an introduction to hexadecimal. https://learn.sparkfun.com/tutorials/hexadecimal Now, back to the terminal. $ echo \"Hello!\" > file4 $ xxd file4 xxd is able to convert a file into its hexadecimal representation. If you do not have it installed, install it with apt-get. Download this image using wget or curl: https://raw.githubusercontent.com/hoppersroppers/hoppersroppers.github.io/main/_layouts/compass.png Open the file with xxd and check out what is in it. Shouldn't make much sense, but it should at least look cool. File formats (and networking protocols, and all sorts of other things on the internet) are defined in documents known as RFCs. All files follow the rules for their file format. Read through the .png format RFC and find where the file signature, aka the \"magic number\" is defined. Don't even think about reading the whole specification, just look for what you need and move on! https://tools.ietf.org/html/rfc2083 Nobody has this content memorized, but when they deep dive into a format or protocol, the RFC has the answers. You'll spend plenty of time looking through RFCs, but not right now. It makes your brain hurt. Any time you need to deal with a file format, google/wikipedia will provide most of the answers. If you need to dig deeper than that, go to the RFC. Hex-editing xxd is not really a hex-editor, it just displays hex. However, we can use it to convert files into hex, make edits to them with our favorite text editors, then convert the files back into the correct formats. First, let's make a copy of the .png you downloaded using cp and name it \"copyOfPng.png\" We can then use xxd to convert the file into a hexdump. $ xxd copyOfPng.png > hexDumped Now if we open hexDumped with our text editor of choice we can see that it is in a new format. Make an edit to the file and change the first four characters (the magic numbers) to be 0000. Save your changes and go back to the terminal. Now we will use xxd to rebuild the file from hex. $ xxd -r hexDumped > modified.png Try to open modified.png. It shouldn't be opening now because we mangled (that's a technical term for corrupted) the file header! diff One useful tool to find the difference between files is to use diff. diff takes two pieces of text and compares them, looking for differences. With text files usage is as simple as $ diff file1.txt file2.txt and the results will display. It is slightly more complicated with binary files or other dense formats like images. To see what the difference between the original image and the new mangled file we were playing with before: $ diff -y Little bit of fancy footwork going on with redirectors here!!!! We are converting the images to hex with xxd, then redirecting them, then using them as arguments for the diff command. This will display the differences between the two files. diff is great, you will use it all the time. There are GUI versions of diff, but I also really like using online ones in browsers. Saves some time when you need it, and usually very good. I recommend https://www.diffchecker.com/. To fix this mangled file header, we will use a hex-editor. Hex-editors do a similar thing to xxd, but also give us the ability to edit in a nice GUI. The one we will use is bless. It is not particularly fancy but it gets the job done. To install: $ sudo apt-get install bless To open up the mangled file, run $ bless modified.png. Now, using the RFC, correct the mangled bits on the front so that you are able to open the image again. Base64 Base64 is another encoding scheme that uses, you guessed it, 64 characters to represent data in an ASCII text format. Base64 is commonly used to encode binaries that would not be able to be sent via methods that only use ASCII, such as in HTML, in URLs, or in some email formats. Base64 is visually distinctive because of its use of \"=\" at the end of a string of letters and numbers. Most of the time when you see that form, it will be Base64, simply based off of how common Base64 is. Don't worry too much about why there is an \"=\" sign, it is for padding to make translation easier. To manipulate Base64 in the terminal, we use the command base64. $ echo \"Hello World\" | base64 $ echo \"Hello World\" > 64dText $ base64 --decode 64dText $ base64 --decode SGVsbG8gV29ybGQ= It isn't often that you have to do this from the command line, but it happens occasionally. For this assignment, I am going to have you convert between encodings by hand. This is meant to ensure you understand what is going on. Don't cheat, and don't move on until you get it, this is very important you understand. Assignment: Alright. Now. Convert 17 in Ascii to Binary and Hex. Do it by hand. Convert \"Go Navy\" to Octal, Hex, and Binary. Yes. By hand. Use Google to figure out how. This is supposed to not be fun. What does \"c2l4dHlmb3Vy\" translate to from Base64? It is annoying to do that by hand, but it does help in the long run. ... but here is a tool so that you never have to do that again as my apology for making you do it. https://gchq.github.io/CyberChef/. Fun fact, it is released by GCHQ, Britain's version of the NSA. Great tool and very useful for converting encodings/encryption, but there is so much more. There are about a thousand uses for this thing and many security professionals use it all the time. I love it for CTFs. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/0-LinuxFilesystem.html":{"url":"AdvancedLinux/0-LinuxFilesystem.html","title":"Linux Filesystem","keywords":"","body":" Here there be dragons! Anytime you start playing with the filesystem, especially the dd aka \"disc destroyer\" command, you are playing with fire. Do not allow bad things to happen to yourself, always always always triple check what drive you are reading from and writing to. Do not be a victim... I've done it multiple times if we are being honest, but... not recommended. Filesystems The Linux filesystem is in a standard hierarchical setup. There are a few different file systems, but the majority use a filesystem named ext4 these days. Don't worry too much about what that means, you can ignore this abstraction 95% of the time. There can be multiple filesystems (often called drives) on a single OS. We will run this command to see all the filesystems hooked up to our computer! $ df df has a ton of output, but we can ignore most of them, we are looking for your primary drive, so it is almost certainly the largest. Most likely it will be called /dev/sda_ , but who knows! For the rest of this page I will be calling it /dev/DRIVENAME. 'df' does a lot of things (like expanding hard drives when you run out of space in your VM!), but we won't worry about that right now. Filesystems are split up into blocks for ease of navigation. $ sudo blockdev --getbsz /dev/DRIVENAME The blocksize will probably be 4096, the ext4 default, but it's worth checking. Drive Layout Here is a quick diagram on how the filesystem is laid out on your drive. [B][S][Inode List][ Data Blocks ] | | | +-- Super Block +----- Boot Area Don't worry too much about what is going on in the Boot Area or the Super Block yet, that stuff is handled for us by the OS and doesn't affect day to day life for us. Starting with the Inode list, think of it as the front desk of a library that keeps information on all the books (files) in the shelves. You can learn where each book(file) is stored, last time it was checked out, and more from the information in the Inode list. Once you know where the book(file) is, you can use the information you got from the inode list to go look for it. This is what the OS does every time you open a file, but it has been abstracted away from us having to do it. Inodes are the pointers OSs use to give the location of a block of data. Whether it is for a file or a directory, there will be an inode associated with it. These inodes are all stored together in a table towards the front of a file system on a drive. By reading the data located in the inode table, the OS is able to calculate the correct offset into the Data Blocks required to find the file. This is why inode stands for Index Node, because it helps us find where we put all of our files. As we said, each file has its own inode number. We can get it with ls -i fileName. Let's go and read a file in the most convoluted way possible! First, choose a file you want to read and make sure it has content. Run ls -i fileName. This command will print the inode number for the file. We then copy that number to the clipboard. debugfs is a powerful tool for working directly with the drive, and we can use this particular incantation to print out the information of the inode we have selected. Anytime you work with debugfs you should probably have a cheatsheet available, and the man page of course. $ sudo debugfs -R \"stat \" /dev/DRIVENAME There is a lot shown in the output, but the only thing that matters to us right now is the block number, labeled as \"Blocks:\" or \"Extents:\"\" with a numeric value, for example, \"547473\". If the file is large enough you might get multiple Extents or Blocks, in which case things get more complicated. Whether it says Blocks or Extents, save that number. It is the number of blocks from the start of the drive that the file is located at. With that offset number and the block size we can then use the notorious dd to calculate how far into the drive we need to go find our file. Before running this command, check over what you have as your input and output. Right now the input file is the dummy text \"/dev/DRIVENAME\" and the output file is \"fileRecovered\". If you switch your input file and output file once you put the actual drive name in, you will nuke your primary drive. Please do not do that. $ dd if=/dev/DRIVENAME of=fileRecovered bs=4096 count=1 skip=547473 Going through this command in order: dd is the disc mount command We specify as the input /dev/DRIVENAME, the drive the file is located on We specify as the output fileRecovered, as the file name for whatever we find there bs is block size and is set to whatever --getbsz told us for the drive count is for the number of blocks we are expecting to find skip tells us to skip that number of blocks into the drive to where the inode table told us our file would be When this command is run, we expect to print whatever is at that location in the drive to be saved into fileRecovered. In this case, it should be the contents of the file we initially got our inode value for. What Happens When You Delete a File When you rm a file the inode data that tells us what the LBA leading to the file is will be zero'd out. This means that it no longer is useful to find the block offset. Once this inode table has been zero'd out, whatever block it previously reserved is fair game for the file system to put new data in... but that does not mean that the data itself is gone! If you already know the offset this is easy, use the same command as before with dd. Because it doesn't go through the inode table there is no effect. However, if you don't have the offset not all hope is lost. How to Recover a File AUTHOR's NOTE: Yes there are sketchy ways to recover a file via processes, but that is like, a lot. Maybe I'll teach it later, but not now. First, you want to turn off the computer. Again, once those blocks are freed any process can write in them, and it gets more likely as time goes on. By turning the computer off you guarantee those files can't be written over. By booting into a turned off computer with a separate OS (this is outside the scope of the course) we can then mount the affected hard drive as read only. From there, we can search through the hard drive for the raw file and hope we can still find it. Now we are using grep again, this time to look for a known pattern in the file and then take 500 bytes before and after and save it to a file named /tmp/recover, as well as displaying it on the screen. $ grep -a -C 500 'known pattern' /dev/sda | tee /tmp/recover Instead of using grep we can use an actual recovery tool. Just like grep for a known pattern, file recovery tools know what the file format is for files like images or videos. Instead of needing to know the offset on the drive, they can just scan through until they find the correct file format headers and save the rest of the file. You'll learn more about this in the CTF course. Metadata Metadata is the information about a file, rather than the data contained in the file. Most file formats have room for metadata towards the front of the file, which means that the metadata for the file is stored inside of the file, but is not considered to be part of the file itself. It is possible to remove the metadata for the file without affecting the way the file displays. To find information about metadata for a specific file format, check the RFC. To pull the metadata from a file, use a tool for it, like this one: http://exif.regex.info/exif.cgi Check out the metadata for this file: https://raw.githubusercontent.com/ianare/exif-samples/master/jpg/gps/DSCN0029.jpg Another type of metadata is filesystem metadata. Rather than being included in the file itself, it is stored in the inode table. Use ls -i to get the inode information for a file and then use debugfs -R \"stat like we did above to get all the information for the file, including the filesystem metadata. A third type of metadata is information about who sends and receives information. Even if the content can't be decrypted, just knowing who sends to who is useful information and can be dangerous depending on the context. This article from the EFF is great. Assignment Questions: 1. Where are drives located on Linux? 2. Explain how the inode table is used to find saved files in a few sentences. 3. What happens when you delete a file in a few sentences. 4. What is metadata? Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/1-LinuxFilesystemHierarchy.html":{"url":"AdvancedLinux/1-LinuxFilesystemHierarchy.html","title":"Linux Filesystem Hierarchy","keywords":"","body":" Previously we talked about how files are saved in Linux, and we've spent some time making directories. However, we have been generally fairly constrained in our working directory, and it is time to learn what the world outside of our user's directory looks like. This world is organized according to what is known as the Linux Filesystem Hierarchy Standard (FHS). The FHS is maintained by the Linux Foundation, and much like a lot of the other standards we have talked about is a recommended standard so that code written for one Linux distribution will be cross-compatibile with another. Primarily, the FHS is a way of organizing user, program, and system files in a tree-like hierarchy, which makes it easy for us to install, uninstall, and find specific files. Important Directories '/' aka Root Our tree starts from '/', the root. No matter what device a file is on, it will be accessible from the root directory. Root is the highest level of the hierarchy and everything falls underneath it. To access root, we use the representation /. Right now, cd into root. From there, run ls to see the available directories. Root Directories Read through [https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\\](this link) and click through the files a bit to get an idea of what is going on in each of the root directories. If you do not have internet access, you can access information on the FHS with ```man file-hierarchy``. This is a weird part of Linux as what we see today is the end result of years and years of design tradeoffs, historical reasonings, and heated debates. A few directories don't really make sense anymore, a few things are brand new. All of this is critical in the \"In Linux, everything is a file\" philosophy. For your assignment, describe the following directories and what is saved in them. If there is anything notable about the use of the directory, or how the permissions are applied, please include that. I expect you to have a large number of Pre-Questions for this assignment, and it will take you a reasonably long time. Don't beat yourself up too hard about this, but instead use it as a way to assess your current understanding and fill in your gaps. If anything is completely foreign to you, let me know in your feedback and in #feedback. / /root /boot /bin and /sbin /etc /home /lib /usr /var /tmp and /var/tmp /dev /mnt and /media /proc and /sys Please respond in the appropriate format: I know this is a longer assignment but it is very important. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/2-ResizingYourVM.html":{"url":"AdvancedLinux/2-ResizingYourVM.html","title":"Resizing Your VM","keywords":"","body":"While we are on the topic of storage and drives, let's spend a little time on one of the more stressful and complicated parts of computing, modifying hard drives. I mentioned the dd command, aka disc destroyer, earlier, but now we are going to do one of the easier and more common tasks you can find yourself having to do. When you built your VM the first time, you probably just agreed to whatever the default virtual hard drive space was and that's how your system was built. But now, you're installing all these new packages, downloading all these memes, and you will find yourself running out of space. Running out of space can look very weird on Linux, from not being able to log in, to random bugs in programs, to just getting notifications that you can't make any new files. Let's learn how to resolve that by expanding our virtual hard disc! Best Practices Any time, and I mean, any time you are playing around with hard disc stuff, just make a backup of your filesystem ahead of time. Usually you'd do this with dd but because we are a VM it is as easy as taking a snapshot. Go play through your virtualization software's settings to take a snapshot. Once you have expanded your disk and nothing is broken, then you can delete the snapshot. Look at you, following best practices. Expand Your Virtual Disk Starting from what we already know, let's think about this in terms of partitions. We know we only have one partition in our virtual disk right now. Let's say it looks like this. __ Virtual Disc: 20 GB_____________ |__Ubuntu Partition __20 GB_______| So all 20 GB of the virtual disc are occupied by our partition, which means our first action is to expand our Virtual Disc size. This will change based off of your Virtualization software, so here are some links. For now, let's just increase your VM disk size by 2 GB. VMWare Expand VirtualBox Expand HyperV Expand It's all pretty straightforward for the virtualization software, but you will notice you have to turn off the VM. Once you're done, your virtual hard drive will look something like this. __ Virtual Disc: 22 GB______________________ |__Ubuntu Partition __20 GB_______| _______| Those extra 2 GB hanging out are called \"unallocated space\". Sounds badass right? So even though you resized the disc, your partition is still the same size and you'll still have out of disk space errors. The next step to fix this is to expand the partition out to fill the entire space. As a side note, there's a Maryland hackerspace named Unallocated Space and they're really cool folks. Expanding Your Partition Now there are hundreds of ways to expand your partition, most of which involve gparted which would be my recommendation if you were doing something more complicated... but we are not. For now, we will use this sequence of commands, which I found in a StackOverflow post. To the best of my knowledge, this is the easiest way to expand your partition out there. Use df -h to find the name of your partition. Look for the one that is the largest. enter the command cfdisk. Choose the partition to extend and select \"Resize\". Set the \"New size\", filling up the rest of the available area. After pressing enter, you'll see screen with the following note \"Partition [someNumber] resized\": Next you'll need to \"Write\" to save your changes. Type \"yes\". Quit cfdisk. When you exit you may see message \"syncing disks\", but either way good things are happening. Get filesystem name again for next step with df -h. Nothing should have changed yet. Now using the name you found for the filesystem, run the following command with resize2fs. This command will automatically match the size of the partition to the size of the available disc space. Magic! $ resize2fs /dev/nameOfFilesystem resize2fs 1.42.13 (17-May-2015) Filesystem at /dev/nameOfFilesystem is mounted on /; on-line resizing required old_desc_blocks = 1, new_desc_blocks = 2 The filesystem on /dev/nameOfFilesystem is now 4854784 (4k) blocks long. Then verify everything worked using df -h again to see the size change. __ Virtual Disc: 22 GB____________________ |__Ubuntu Partition __22 GB_______________| Now you have changed your VM size, which is a huge win for something that is usually very stressful. The next time you have to do this, or help someone else, refer back to this! Add More Processing Power to Your VM While we are here, let's also look at what we can do to speed up your VM. If you haven't tried it already, play around in the options to add another CPU, or add some extra RAM. See what the constraints are. We don't need to worry too much about the effects of adding another vCPU or extra RAM are to our system, but it's worth checking out for the knowledge. Assignment: What is a snapshot? Why are they useful? Why do you think we have to turn off the VM to resize the virtual hard disk? Why do you think we can expand the partition while the VM is running? Why do you think we don't have to turn off the VM to resize the RAM? Answer in the usual format, one or two sentences. This is more about your feelings and what you can find in 5 minutes of research than a perfect answer. Don't research this too deeply or you might lose your mind! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/3-LinuxPermissions.html":{"url":"AdvancedLinux/3-LinuxPermissions.html","title":"Linux Permissions","keywords":"","body":"Alright, we went over a little bit of this earlier, but let's dive into permissions. Permissions are security, and is one of the most important things that an OS provides. We haven't put much time into it yet, but the OS basically segregates user and root process privileges using something known as \"Protection Rings\". Even though rings 0-3 are shown, basically no major OSs use anything but Ring 3, Userspace and Ring 0, Kernel Mode. This is enough separation of powers for a level of protection to be given to the kernel by locking off userspace programs from accessing critical kernel functions. A very common misconception is that when you run as root, with sudo or otherwise, you are running in Ring 0. Not true! You are still in Ring 3 as a userspace process, albeit as UID 0 which gives you 'root' powers as granted by the configuration of the system. You will never transition to Ring 0 without control of a kernel mode driver (which is wildly out of scope of this course and 99.99% of jobs that require Linux). Secure defaults and well-implemented permissions go a very long way towards making your Linux experience as smooth as it is. Userspace is all that really matters to us, so first, let's go over how permissions are represented, whether it is for the root user, background daemons, or everyday users. Basics Run ls -l on a directory and look at the results. Should look something like this: drwxr-x--- 2 username groupname 4096 Jan 21 14:02 folder1 -rwxr-x--- 1 username groupname 15 Jan 21 14:02 file2 We went over this a bit earlier, but for old time's sake. The first bit tells us what type of file it is \"d\" means directory \"-\" means normal file There are more options that can go here, but these are most of them The next 9 bits are permissions bits This is what we are about to learn!! The next bit, a number, tells us how many hard links there are to the file, but don't worry about it The first name is the username who owns the file, in this case you The second name is the group who owns the file. Unless you've set up a group already, this should also be your username The next number is the file size in bytes Directories are always the same size, but individual files should be listed as the number of bytes that make them up The next numbers should be the date and time last modified. These are not forensically accurate but are good enough to sort by timestamp. Finally, the name of the file you are looking at the details of With that reviewed, let's dive into permissions. What do we do with these nine bits? It's actually a sort of straightforward thing. The nine bits are split into three triplets that represent the perms (the cool way to say permission) for \"User\", \"Group\" and \"Other\". User Group Other rwx rwx rwx rwx r-- --- r-x --- --- As you can see, these triplets are comprised of \"r\",\"w\",and \"x\", which stands for read, write, and execute. Read means to access the file and read the bit stream, write means to modify the location in the drive, and execute means to run the process (assuming the file is an executable). The lack of permission to do one of those actions is represented by \"-\". This is constant across most OSs. User and Group are defined by the names we see to the right of the permission bits when we run ls -l. So if we see: -rwxrw--- 1 jimmy students 15 Jan 21 14:02 file2 This means that the user 'jimmy' has read, write, execute perms, while the group 'students' only has read and write. Any user who is not in the group 'students' has no permissions whatsoever, not even to read the file. We haven't made any groups in our VM yet, so most likely when you run ls you see your name for both user and group. That makes sense, don't worry about it. Modifying Permissions Now things get fun, let's change some permissions around! We use the command chmod and either \"u\" (for user), \"g\" (for group), \"o\" (for others), or \"a\" (for all 3) to do this on Linux. It's fairly straightforward, we either add (\"+\") or remove (\"-\") permissions with \"r\", \"w\", and \"x\". Here are some examples. $ chmod g+x file2 > I bet you can guess what that does: add the executable bit to the group permission for file2. > Run ```ls -l``` again and you will see it has changed. $ chmod g-w directory2 > Now we have removed the write bit for a directory2 for group. $ chmod a+x file2 > Now we have added the executable bit for everyone. We can use chmod to modify any permission on the file we own, as long as we have the permission to modify permissions. The most common use of chmod is when you download a file from somewhere, it is not given execute privs by default due to security policy. So anytime you find an executable not executing, you should check a chmod. If we want to change permissions on something we don't own, you're going to need root access for that. Let's play around with changing ownership of files before we do that. Again, you'll need root access to change ownership. $ sudo chown root file2 Now when we ls -l we see that file2 is owned by root. When the sudo command is finished running we drop back into our normal permissions (run whoami to check). If we try to change permissions now with chmod we will get a permission denied error. However, using sudo we can elevate privs again and chmod the permission around because we are the owner. This works for a file owned by any user, if you are root you can do what you want. It's good to be the king/queen. Similar to chown is chgrp which, you guessed it, changes the group. Basically the same usage as chown. A final thing we can do is set something known as \"the sticky bit\". $ chmod +t file2 $ chmod +t directory2 This \"+t\" sets a file or directory as not-deletable by anyone other than the owner and root. This is great for shared folders. Bits and Permissions Because of the magic of binary, if we have three bits, those bits can range from \"111\" to \"000\" which represents 7-0. This allows us to represent permissions as numbers as well. The read bit is \"4\" The write bit is \"2\" The execute bit is \"1\" With three triplets, now our permissions look like this: 111 111 100 This is actually what the computer sees, so congratulations on finally getting inside the matrix. This is a big day! Because we can add up the bits in binary, the \"rwx\" we were getting used to can also be represented by \"111\", \"421\", or \"7\". Lost yet? Keep thinking about this until it makes sense. Now that you get it, this also allows us to set perms in chmod in a much cooler way. $ chmod 755 file2 Damn that looks way more hardcore, you're using binary in real life. Look at you go. Adding up the bits lets us know which perms are on. All perms for everybody is represented by \"777\" but you should avoid doing that, it's the opposite of the Principle of Least Privilege. You can also remove permissions by using lower numbers. $ chmod 744 file2 There we just removed the execute bit for group and others. Assignment: Submit a brief explanation of what the sticky bit is and anything you don't understand. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/4-PermissionsandUmask.html":{"url":"AdvancedLinux/4-PermissionsandUmask.html","title":"Permissions and Umask","keywords":"","body":"When a file is created in Linux, the default permissions for it is \"666\". For a directory, the default permissions are \"777\". That is basically always fine, but if you need to for some reason, you can modify the default permissions using a command named umask. Masks Okay, things are about to get a bit weird. You saw a little bit of binary addition in the tutorial and hopefully that made some sense. Now, you're going to learn about masks, which are a completely different thing than binary addition. To avoid getting confused, keep in mind that masks and binary addition have nothing to do with eachother, besides all the 1s and 0s. Masks are all over computing and generally can be defined as strings of bits that set other bits based on logic. This logic is based on the Digital Logic Gates we learned about in the \"Digital Logic\" section. Depending on the required implementation, different logic gates can be used for different masks. This means that the logic for a gate can be \"AND\", \"OR\", \"XOR\"... long story short, don't think of masks as any specific thing, just read what the logic is for that specific scenario and reason about that in your head. One of the more common uses of masks we see in Linux is for controlling default permissions. EX. 1 Binary: 6 6 6 // 110 110 110 Mask: 0 2 2 // 000 010 010 Output: 6 4 4 // 110 100 100 EX.2 Binary: 7 7 7 // 111 111 111 Mask: 0 4 2 // 000 100 010 Output: 7 3 5 // 111 011 101 Hopefully this makes sense. Honestly, you won't use this much, but it is good to know about. The most common place where you will see permissions masks is with the umask command. Run it now and you will see what your shell's default masks are. Now make a new file and use ls -l to see what the permissions are. Do they match? In order to change your permissions that files default to for your shell: $ umask 002 This umask of \"002\" converts over to being a mask of \"775\". When applied to This will change permissions so that files come out RWX for user and group and R for other, but don't just believe me, test it out. You might have noticed that when you ran umask the first time there was a leading \"0\" in front of the other numbers. That first bit is the special bit we talked about earlier in terms of the \"sticky bit\". There are other special types of files that can be indicated in the special bit location, but don't worry about them for now. For your assignment, discuss which bitwise operation is occurring when the masks is applied. Answer in the appropriate format. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/5-BoredYet.html":{"url":"AdvancedLinux/5-BoredYet.html","title":"Bored Yet","keywords":"","body":"Alright, I'm gonna be honest. Doing all these Linux Journey assignments can be super boring, and is a ton of hard work. If you want to split it up and do some theory, I really recommend you check out our Intro. to Security course. https://www.hoppersroppers.org/courseSecurity.html It's a nice change from marching through Linux commands like this and will give you a good base to apply the knowledge you learn in this course to the real world. If you think you have good momentum right now, just keep pushing! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/6-LinuxUserManagement.html":{"url":"AdvancedLinux/6-LinuxUserManagement.html","title":"Linux User Management","keywords":"","body":"While being a system administrator covers a ton of responsibilities, potentially the most important on the day-to-day is User Management. As people come and go from a network, passwords are forgotten, the organization structure changes and the sysadmin rules over all and ensures everyone has the permissions they need, and perhaps more importantly, doesn't have any permissions they don't need. We manage these using Users and Groups in Linux. The Operating System maintains the distinctions between Users and between Groups for us, but as sysadmins, we have to tell the OS what to do. The security provided by the OS is only as good as we define it, so if our permissions we tell the OS to enforce are incorrect, we can have no security at all. Users are differentiated and monitored by the OS according to User ID (UID). Groups are identified using, you guessed it, Group ID (GID). When we attempt to open a file or a directory, the permissions for the file are checked against our UID and GID. If all the checks pass, we are given access. As your normal user you can use cd to enter the \\home directory to view your user directory. You can also back out into root and attempt to read the \\root directory with cat. As you are not root and do not have the permissions, this will fail. Check out the permissions of the directories in / using ls -l and see why. /etc/passwd While usernames are used in the human-visible interface for computing, behind the scenes, the OS operates using the User IDs (UIDs) we already talked about. As different operations occur, the OS checks these UIDs against a file that is represented in the Linux filesystem as /etc/passwd. All of these files can not only be viewed, but can be edited if you have the appropriate permissions. On rare occasions you might go into these files in 'vim' to make edits. To view: $ cat /etc/passwd Here you will see a printout of all the users with accounts on your computer. The top one will be 'root', and will look like generally like this. root:x:0:0:root:/root:/bin/bash dennis:x:1337:1337:Dennis:/home/dennis:/bin/bash There will be many more entries than this, but let's ignore them for now. We will learn about how this file is broken down using \"man passwd\" To break it down, /etc/passwd stores data about users separated by colons (:). User name Encrypted password On modern systems, the password will not be stored here and is indicated by an 'x'. We will learn about where the passwords are stored next. User ID number (UID) User's group ID number (GID) User full name and other data(GECOS) This is an arbitrary set of data also known as the \"comment\" field. Sometimes name, email, phone number, separated by commas. Most of the time, there is nothing here but your name. User home directory Default Login shell /etc/group Similar to /etc/passwd, this prints out information about the various groups on the computer. roppers:*:1337:dennis, grace Group name Group password - Using an elevated privilege like sudo is standard, but a separate password can be added. \"*\" will be put in place as the default value. Group ID (GID) List of users - Manually specified users in the group Add a User and Set the Password $ sudo useradd -c \"User's Full Name\" account_name $ sudo passwd account_name Delete an Account To delete an account: $ userdel -r account_name Userdel with the \"-r\" flag is final and will delete the user along with the user's home directory. Make sure you want to do this before running the command. Set Passwords While usually you will use passwd to set passwords, there are many other uses. To check the status of a user account, use this format. $ passwd -S account_name You can also do more complicated things using the command, but google for a cheatsheet to do that, or if you don't have internet access, use man pages. Assignment: Break down this entry from /etc/passwd. Describe each field. dennis:x:1337:1337:Dennis:/home/dennis:/bin/zsh What does this passwd command do? Work through each argument on a separate line. $ sudo passwd -n 1 -x 120 -w 4 -i 10 dennis Create a new account, set the password, check the account in /etc/passwd. Delete the account. Check /etc/passwd again. Briefly write up what you saw and any problems you had doing this. Answer in the appropriate format. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/8-PasswordsandHashingOnLinux.html":{"url":"AdvancedLinux/8-PasswordsandHashingOnLinux.html","title":"Passwords and Hashing","keywords":"","body":" A good deal of security is based around the idea of confidentiality, that someone who is not authorized to read something can't read it. We discussed the idea of permissions earlier, where someone who is not authorized to read something is simply not granted access to it by a computer, but there are situations in which we need to send or otherwise expose sensitive data. To allow data to be exposed without authentication, we need a way to protect that sensitive information from people who don't know some sort of secret. This is where math comes in. There are two primary ways to protect the confidentiality of secret information: Encryption and hashing. Let's go into each a little bit, but we will focus on hashing here. Encryption Encryption is something you've definitely heard of before, it's the lock on HTTPS websites, it's what we are supposed to do with sensitive files before we send them via email, it's everywhere. Encryption, at it's fundamental level, is doing math and having some sort of shared secret between the sender and the receiver that any adversary who is listening in doesn't have, so the sender can encrypt and the receiver can decrypt, and the adversary doesn't know anything other than that a message got sent. There's a ton to learn about the study of encryption which is known as cryptography, and I have a giant section in my CTF course about it if you want to learn more. Encoding and Obfuscation One big giant step down from encryption is encoding and obfuscation. While they might look like encryption, they are really just ways of translating data into another form. While you might need to spend some time figuring out how it is obfuscated or encoded, there is no math involved so it is far from secret. Encoding is notably not always a security measure, and can be used to get data into an acceptable format for transfer. One common example is Base64 encoding, which can be used to convert a binary into printable ASCII text. Hashing Finally, we get to hashing, the star of this lesson. Hashing is what we use if we wanted to encrypt something so that it could never be decrypted again. What does that mean, you're probably thinking. Hashes are designed to be mathematically one way, meaning it is impossible to reverse a hash into the data that was used to create it. Hashing functions are algorithms that take in any data, do math on it, and output a string of some set length depending on the function, that can be assumed to be unique to whatever the input was. To put it another way, no two inputs should result in the same output hash (that doesn't mean it's impossible, and it's very interesting when it does, but that is outside the scope of this course). Let's play around with hashing to try and get an idea of what this means. One of the more famous hashing algorithms is md5, so we'll use the 'md5sum' utility that should be included on your Linux machine. Run this command, which takes the string \"password\" and gets the md5 hash of it. $ echo \"password\" | md5sum Now, run this command. $ echo \"password1\" | md5sum As you can see, the outputs are completely different. As a sneaky note, the echo command automatically adds a newline character to the end of our input (so \"password\\n\" so that the terminal can display it properly. This is a function of how terminals buffer text and display things and it doesn't matter often, but in this case, it completely changes our output because of how hashing functions work. To get the actual MD5 hash of the string 'password', use echo's '-n' flag to remove the trailing newline. We can also use hashing on files and programs. $ md5sum /bin/ls $ md5sum /etc/passwd This will give us the unique hash of the 'ls' program or or /etc/passwd. If a single bit in the program changes, the hash will be completely different. This is used by many software companies when they distribute software to verify the integrity of their software, as it allows downloaders to verify the hash to make sure the file they received is not corrupted. So hashing is interesting and one way, but doesn't that mean everyone in the world who gets the md5 hash of \"password\" has the same value? Absolutely. For a fun check, google the hash of 'password' and you'll find that it is everywhere. What does that mean then, that we can't use the password \"password\" anymore because someone can view hashes, crack them using a dictionary of common words, and then use it to log in? Well you shouldn't use common words, but that's not actually much of a problem because of something known as salting. Salting Salting is a very cool technique where a computer or website creates a unique string to place at the end of every password entered.This means that they can leave their hashes publicly readable, but an attacker is going to have a much harder time cracking them. Let's demo this, as if we were a user setting their password for the first time on a system with hashing enabled. $ echo \"password&secretsalt1337\" | md5sum So here we are emulating as if the user entered their new password \"password\", the system added on a salt, in this case \"&secretsalt1337\", and then the system saves the salt and the output of the md5 hash. The original password entered will not be saved anywhere. Now the next time when you enter your password, it will be combined with the salt stored on file, hashed, and then the hash will be compared to the hash on file, not any stored password. We'll come back to this later, but it's 2021, there is no excuse to be storing someone else's password. /etc/shadow As we showed earlier, modern Linux versions don't store passwords in /etc/passwd. Instead, they have been moved to /etc/shadow. So now, guess we just have to cat /etc/shadow instead, right? If you have been paying attention to this course so far, you probably guessed that wouldn't work. If you check the permissions, in order to read /etc/passwd, we need root access. So now we try it with superuser privileges and we should see the results. There should be a bunch of entries, but let's break one down. dennis:$6$iU9KjTeD$5myyo4W7zppTOEdVUeP8/E6Kmjl7CtYYFqIIyes.fnNHy1fR0gJLb0q2KLhjAH6KrPpHZ0eJorBh.D74mq.vQ.:17952:0:99999:7::: Briefly read through the man page for \"shadow\" and see the breakdown: man shadow The most notable part of this is the password field, field #2. To break it out, we can see that it is represented by: :$6$iU9KjTeD$5myyo4W7zppTOEdVUeP8/E6Kmjl7CtYYFqIIyes.fnNHy1fR0gJLb0q2KLhjAH6KrPpHZ0eJorBh.D74mq.vQ.: Notably, you can't actually read the password! Let's break this field down ever further: $6 This represents the hashing mechanism we are using to generate the hash from this password $iU9KjTeD This represents the randomly generated salt used Remember how we were talking about salts earlier? In Linux, the salt is randomly generated for the user when they are created. These salts are different for each user. $5myyo4W7zppTOEdVUeP8... This is the resulting hash of taking the user's password and the randomly generated salt When a user types in a password, the OS takes the input, adds the salt that is saved in /etc/shadow, hashes the string, and then compares the output to the saved hash in /etc/shadow. If the hashes match, access is granted. So you might be asking, what is the salt for if an attacker can figure out what it is, and then run a dictionary of common passwords against it, to create a bunch of hashes, then compare those hashes to the hash saved in /etc/shadow? Well, the answer is that it is super inefficient to do that for every user. Without salts, attackers would only need one giant list of hashes to check against. With salts, for every user they need to run a new cracker against the hash. That is technically difficult and expensive enough that very few attackers will ever take the time to do that for your password. You're just not special enough, which is a good thing. Beyond this format, there are a few other characters that can be saved in an /etc/shadow password field. The use of \"!\" or \"*\" in this field indicates that the account cannot be logged into using a password, and must instead be logged into using an alternate method, such as an SSH key. This minimizes risk by forcing an attacker to know or have something besides a simple password. As a note, on modern Linux systems there are a variety of authentication methods (usually known as PAM) which use /etc/shadow in various ways. They are outside of the scope of this course, if you ever find yourself in a job that focuses on Linux auth, blame me for not teaching you more... and then teach yourself. Lock or Delete an Account If you need to lock an account so that it cannot be logged into, but still exists, use this command. $ sudo usermod -L account_name It will modify the /etc/shadow file to have an \"*\" in front of the password field so the account cannot be logged into. Check this using cat. To delete an account: $ sudo userdel account_name Assignment: What is in /etc/shadow? Describe how hashing, salting, and cracking work from the perspective of a defender. Break down this entry from /etc/shadow. Describe each field. especially focusing on the password field. dennis:$6$iU9KjTeD$5myyo4W7zppTOEdVUeP8/E6Kmjl7CtYYFqIIyes.fnNHy1fR0gJLb0q2KLhjAH6KrPpHZ0eJorBh.D74mq.vQ.:17952:0:99999:7::: Create an account, set the password, check the password in /etc/shadow. Then lock the account using usermod, check the password again. Now, unlock the account, you will have to Google or use man pages for this. Check /etc/shadow again. Briefly write up what you saw and any problems you had doing this. Answer in the appropriate format. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/9-HowtoType.html":{"url":"AdvancedLinux/9-HowtoType.html","title":"How to Type","keywords":"","body":"This is not required... but you should learn how to type with your fingers on the home keys. I'll be honest. I don't do this. I have a very fast words per minute hunting and pecking with all fingers. My hands look like demented spiders when I type. It's not great. I know I should force myself and someday I will. This is an investment in your productivity, the faster you can type, the better your life will be. It is important to note that fast typing will not make you better at programming or at hacking. It is commonly said that \"typing is not the bottleneck\". When you are working, it doesn't really matter how fast you type, because you won't be going faster than your brain. The only thing I find it helpful for is so I don't have to look at the keys when I'm copying something, which is slightly useful However, this matters for everything else you will ever do on a computer, like writing, taking notes, and journaling. I'm still learning how to do this well. Writing is one of the most important skills you can have, no matter how technical you get. In a future edition of this course, I'll have a better section on soft skills. https://www.how-to-type.com/ If you want to learn how to use the home rows, I highly recommend it. If you don't want to do the home row thing and are dedicated to hunting and pecking like me, get those WPM up and call it a day. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/10-LinuxProcesses.html":{"url":"AdvancedLinux/10-LinuxProcesses.html","title":"Linux Processes","keywords":"","body":"Suggested Soundtrack: Don't Fear the Reaper. Put it on loop. Here be dragons! \"Here be dragons\" ('hic sunt dracones' in Latin) means dangerous or unexplored territories, mimicking a trend of old-timey map makers putting illustrations of dragons and sea monsters on uncharted areas of maps. It wasn't all that common, but at least it sounds cool. Well, we've talked about most parts of the operating system, but now we are getting to where the magic happens, and also the dragons. I'll still abstract away most of the complexity, don't worry, but this is where I am going to show you the existence of a bunch of complexity, explain the important stuff, and then we will all pretend the complexity doesn't exist so we can go the rest of our lives without having the cursed knowledge that our computers are filled with dragons, and those dragons are filled with dragons. What is a process? Any time you run a program, which includes any command you run in the shell, as well as the shell itself, as well as programs run by the OS, a process is created. Each of these processes runs in memory on the CPU, and that is all I am going to really tell you about the specifics of them in this course. Unless you decide to become an expert in a field directly next to Linux processes, the only things you need to know about processes are how to identify them, modify them, and kill them, so that is what we will do. ps & top The most common way to view processes is by running the ps command. To list all the processes owned by a username, run this command: $ ps -u This will return results in the format: PID TTY TIME CMD 954 tty2 00:00:28 Web Content 1262 pts/1 00:00:00 ps 7020 ? 00:08:38 evince ... and many more PID stands for process ID, and is the unique identifier associated with a specific process. They generally increment as new processes are started. TTY stands for TeleTYpewriter, which is a relic of early computing history. Today it tells us the file name of the terminal connected to standard input. Here we can see \"tty2\",. which tells us second terminal. We can also see \"pts/1\" for the TTY that ran the ps command. 'pts' stands for \"pseudo terminal slave\" and generally is a tab or SSH connection in a terminal. (Note: The use of racially charged terminology such as \"master/slave\" and \"whitelist/blacklist\" have been identified as not appropriate in the modern era by the Linux Foundation and most reasonable people. The Linux project has officially stated that no further code or documentation will be accepted using this outdated language and must be written using more inclusive terms, however, older code will remain unchanged. 'pts' as an acronym will likely never change, and eventually will be even more of an archaic piece of trivia than it already is.) A 'pty' is a \"pseudo terminal device\" is an emulated terminal, and hosts multiple 'pts' inside it. Finally, if we see a '?' it just means the TTY is unknown. The more common way you will see the ps command is this: $ ps aux This returns all the data about all the processes running on the computer. You can check out in the man pages to see exactly what the 'aux' does. USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 173320 16324 ? Ss Mar22 2:28 /usr/lib/systemd/systemd student 32529 0.0 0.0 226464 5352 pts/7 Ss+ Mar30 0:00 bash root 30555 0.0 0.0 257044 10092 pts/3 S+ 10:16 0:00 sudo wireshark avahi 975 0.0 0.0 32136 5440 ? Ss Mar22 1:08 avahi-daemon: running Now in addition to PID, TTY, TIME, and CMD, we have some new options. USER is interesting and shows who owns each process. Interestingly, some of these users aren't us, but are users specifically made to run a process. These processes are called daemons and can be defined as a computer program that runs as a background process, rather than being under the direct control of an interactive user. Looking at the results above, we can see the avahi-daemon process run by the avahi user. A second daemon (traditionally indicated by the trailing \"d\" in the name) we can see is systemd, which has the PID of 1. PID of 1 tells us that systemd is the init process, or initialization process that all processes on the computer were spawned from. Systemd does a ton of stuff, there's a lot of (dumb) controversy around it, just know it exists and that it is the init daemon (the process which starts all the other processes) for modern Linux and move on with your life. Other options visible are %CPU AND %MEM, which tell you exactly who is hogging your resources. VSZ is the Virtual Memory Size and tells us how much total memory is allocated to the process. RSS is the Resident Set Size and is used to show how much memory for that process is in RAM. There is an important distinction between the two about swap space and virtual memory that I don't want you to rabbit hole about (too hard), but I am going to ignore it in this course. Again we have TTY and then STAT, which tells us the current status of the process. There are a bunch of different STAT codes, if you need to understand them man ps and check out the section under the \"PROCESS STATE CODES\". START gives us the starting time of the process, or the date if it has run for over 24 hours. TIME gives us the total CPU time the process has been running. Finally, COMMAND gives us the extended version of CMD, with the path and all the arguments that a process was executed with. If we only want to look for a single type of process, we can grep for it using a pipe! $ ps aux | grep bash If we only care about who is using the most resources, we can use a new command top to check them out! $ top This is especially useful if you are locking up and need to kill a memory hog... speaking of, how do we do that? Killing Processes If you have the process ID, you can simply type kill followed by the PID. top, or ps | grep are great for finding those PIDs. $ kill 1234 If you want to kill all processes with a certain name, pkill is very useful and gets the job done. Great for killing netcat listeners or python scripts when you are doing a bunch of things in a bunch of terminals. $ pkill nc Once you've killed a process, run ps again to make sure you got it. If something went wrong you might need a different kill option, or worse, made a zombie! Types of Processes Alright, before we get to zombies, let's talk about parent and child processes. $ ps -ef Running this we see a bunch of similar columns as before, but now we see a column labled PPID, or \"Parent Process ID\". This is the PID of the process that spawned the process listed, so we can use it to understand who is calling who (especially if we see processes and don't know where they came from). An ever better way to visualize this is this command: $ ps -e -o pid,args --forest We can see a very interesting output that shows the parents, children, and grandchildren, and even further down. We can even see the command and the arguments we passed to display this. 23453 \\_ /usr/libexec/gnome-terminal-server 5868 | \\_ bash 26785 | | \\_ ps -e -o pid,args --forest 22769 | \\_ bash 22812 | \\_ bash There is a lot of processes up towards the top of that printout that will have dozens of children. These are the key processes run by the operating system that makes everything work (like systemd). Don't worry about understanding them, but it's good to be able to find what things are every once in a while. So Parent Processes are the processes which call another process, which is then called the Child Process. That Child Process can then start another process of their own, and they become the Parent Process of that Child Process. So in the example above, PID 23453 is the parent process of child process with the PID of 5868, which is the parent process of child process PID 26785. This makes PID 23453 the grandparent process of PID 26785. When a child process is started, the OS keeps track of it and associates it with the parent. When the child process exits, completion is reported to the parent and the process is \"reaped\" from the process list. This \"reaping\" saves space in memory and is important for normal operation. Orphan processes are processes whose parent process completed execution and exits (or was killed) prior to the child process completing. To handwave some complexity, the OS keeps track of parent and child relationships and informs the parent when the child has died. If the parent has died, the child is not informed, and it just continues to run as normal. This means is that the process will run for however long it is supposed to, and during this time it will be referred to as an orphaned process. When the child completes, the OS sees that the parent process is dead and will \"reap\" the orphaned process itself with systemd, the init daemon with PID 1 we discussed earlier in the section. Again, don't worry about how/why systemd and the OS do what they do, just accept it as a fact of life. Following the same lines, when a child process has completed or exited, the process table is updated to reflect the new status. However, if the parent process does not check the process table to receive notification in a timely fashion, the finished child cannot be reaped. As long as the parent process is alive, the OS will not step in and \"reap\" by itself. This is referred to as a \"zombie\" process, which will not be removed from the process table until the parent checks in on it and reaps it. Pretty spooky stuff to find in a conversation about processes, eh? This stuff is all super complicated but honestly, don't worry about it too much. It's mostly trivia, but it is useful to know and I don't want to be accused of not teaching the basics properly. Backgrounding Another very useful tool we have is backgrounding processes. First, let's run nc -l 1338\" in a terminal window, and open a new window. Next run this command in the new window nc -l 1337 & to setup a netcat listener that \"backgrounds\" itself and returns control of the terminal to us. The output should look like [1] 23867, with the trailing number being, you guessed it, a PID. We can now check out with ps aux to see what these two PIDs look like. student 27347 0.0 0.0 8172 2184 pts/3 S+ 11:06 0:00 nc -l 1338 student 27389 0.0 0.0 8172 2188 pts/3 S 11:03 0:00 nc -l 1337 Besides PID and the command issued, a notable difference is that the 'STAT' column shows S and S+. I mentioned above if you need to understand STAT codes, use man ps and check out the section under the \"PROCESS STATE CODES\". Here are the different values that the s, stat and state output specifiers(header \"STAT\" or \"S\") will display to describe the state of a process: D uninterruptible sleep (usually IO)I Idle kernel threadR running or runnable (on run queue)S interruptible sleep (waiting for an event to complete)T stopped by job control signalt stopped by debugger during the tracingW paging (not valid since the 2.6.xx kernel)X dead (should never be seen)Z defunct (\"zombie\") process, terminated but not reaped by itsparent For BSD formats and when the stat keyword is used, additional characters may bedisplayed: \\N low-priority (nice to other users)L has pages locked into memory (for real-time and custom IO)s is a session leaderl is multi-threaded (using CLONE_THREAD, like NPTL pthreads do) is in the foreground process group Cool, we've seen some of those words before (most of them we haven't), like Zombie processes. Now, looking at it we can see that both of the target PIDs are in an interruptible sleep, with one being in the foreground. Using the command jobs we can see what backgrounded processes are running. Interestingly, if we run jobs in a different tab than where we ran the backgrounded listener, nothing will pop up. This is because they are in a different parent process, so jobs won't find them (Remember, computers are not magic). Once we navigate to the tab we ran the backgrounded process in we can use the fg command to bring them forward. With no args fg will take the first item, otherwise we can specify with fg `%. Now the backgrounded process is in the foreground, and we can check jobs and ps to show the status has changed. Signals Signals are a complicated part of something called \"Interprocess communication\". Interprocess communication is the mechanism the OS provides so that processes are able to work with each other. It is all very complicated, so we are not going to worry about them too much, other than to tell you that they exist and give you a few examples. If you are deeply interested in them, check out this resource, but I don't recommend anything IPC for beginners: 99.5% of technical jobs will never even to know that IPC exists, but now you do, so... hooray? Signals are notifications to a process that an event has occurred. There are a large number of signals, and you can look them up if you ever need them. The most common one you will experience and use is killing processes with signals, which is how the 'kill' and 'pkill' commands work, along with closing browser tabs and terminal windows at the lowest level. But for now, let's do a quick demo on the other common thing we can do with signals. Run the command nc -l 1337 and then press Ctrl-z. Ctrl-Z sends a signal to the OS which modifies the process and automatically stops the process' execution. Notably, it does not background the process, and we need to do that manually with the bg command to get it to continue execution in the background. Now we can check the status of the process with jobs or bring it back with fg. Once you have brought that process back to the foreground and are waiting on it again, press Ctrl-C. This sends another type of signal to the OS and causes the process that is running to recieve an \"interrupt signal\". This will kill the vast majority of processes and is a great way to kill pesky hanging processes. As an important note; there are also things called \"interrupts\" and \"exceptions\" that are similar to signals, but instead of being generated by the OS, they are actually generated by the underlying hardware, usually when a fault occurs. Even worse, there are software interrupts and software exceptions.... so it's complicated. Long story short, if you see signal, that almost always mean OS generated. If you see interrupts/exceptions, try to figure out if they are software or hardware generated. It is all very complicated and will not apply to any beginner material, however, it is important that you get the difference between them all in case you see a reference to them. proc Remember how I mentioned that \"everything on Linux is a file\"? Well, I have a confession to make. The command ps doesn't find all that information for you... instead, it is reading a series of text files that the Linux kernel provides. That is right, you can ls /proc and by looking at the different files in that directory, can find all sorts of information. Now to make it even more complicated, the directories in /proc don't exist until you ask for them so ... things get pretty damn sketchy from there, so we are going to mostly ignore it, but again, it is good for you to know. Assignment: Questions: 1. Navigate /proc and look through a PID associated with a netcat listener. Briefly, what can you find in there? 2. How can we tell a process is a zombie file in ps? (Hint: Process State Codes) 3. What is the difference between a signal and an interrupt? What is an interrupt signal? 4. What is systemd? (Do not try to understand it, only what it does) Answer in the usual format, and I expect you to have a bunch of Pre-Questions, and so many unanswered Post-Questions. Here there be dragons, so don't worry about it. \"Seasons don't fear the reaper Nor do the wind, the sun or the rain, we can be like they are Come on baby, don't fear the reaper...\" default Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/11-OvertheWire1015.html":{"url":"AdvancedLinux/11-OvertheWire1015.html","title":"Over the Wire 1015","keywords":"","body":"Back to OverTheWire again! You finished the first ten levels, time to go back for 10-15! Pay attention to the \"Commands you might need to solve this level\", but remember, you won't need all of them! https://overthewire.org/wargames/bandit/bandit11.html SSH into : ssh bandit.labs.overthewire.org -p 2220 -l bandit10 With the password: G7w8LIi6J3kTb8A7j9LgrywtEUlyyp6s If you ever get stuck on anything for more than a half hour, message us in #techsupport and we will help you out! Don't worry, I have no problems giving you very specific instructions to get to the next stage. If your googling keeps popping up Bandit walkthroughs instead of references, use the search operator -\"bandit\" to clean up the search results. As a hint, 12-13 is a miserable problem and requires guessing. I'll save you from some guesswork. Did you know xxd -r exists? Don't say I never did anything for you. Good luck!!!! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/12-AdvancedBashShell.html":{"url":"AdvancedLinux/12-AdvancedBashShell.html","title":"Advanced Bash Shell","keywords":"","body":" On the surface, the bash shell and all the things you can do with it seem very complicated. In what should be unsurprising at this point in the course, it's even more complicated when you try to understand why and how it works. Of course, you don't need to know most of it, just a few key portions that I'll go over right now. This stuff is pretty hard and honestly, not that important, bordering on trivia. Still, I feel like I should teach it. How Does Running a Command In Bash Work When we type a command in the terminal and it is run, there is quite a bit going on under the surface. To understand how it really works, we have to look at our \"environmental variables\", which provide the information to the shell that is required for it to operate properly. These variables control the shell's behavior, guide access to resources, basically make it work... remember, there's nothing magic with computers, and this is \"why\" shells work. Your Environment Okay, so variables. Where do we actually find them? Using the command printenv we can print out all of our set environmental variables. Most of these aren't all that exciting or important, but a few are worth noting. We can also use echo $and that will print out the content of the env var. SHELL It was mentioned before in the class, but yeah, there are a ton of different types of shells. Different boxes will have different default shells, but generally, they are all close enough to bash to fake. A command I use all the time is printenv SHELL which will give you just the shell value, letting you know what you are working with. printenv can be used like that for all variables, but SHELL is definitely the most common. TERM Describes the type of terminal to use when running the shell... you were just getting used to their being multiple shells, now there are multiple terminals?!?! Don't worry about it much, it's rarely relevant. USER Saves the current logged in user. Try the command su to see what happens~ PWD Saves the current PWD. When you run a command like ls or cat, this is what tells the shell where you are. OLDPWD Saves the last PWD so that you can return to it using the cd - command. Super useful if you cd deep into something and want to cd back out no without \"../../../../\"-ing. Try it out! ! ! saves your last command so that you can access it for a variety of reasons, one of my favorites being the classic !! command which reruns your previous command. It is particularly useful if you try to run a command, it tells you that sudo permissions were required, and then you can run sudo !! to rerun the same command with the correct permissions. There are also more advanced things you can do like run !\\ which will go through your bash history and re-run the last command you ran with that string. PATH Path is going to look like a comma separated list of directories, usually in the /bin area. This is the list of places the shell will look for a binary when a user types in a command. For example, when a user types in \"cat\", the system will search these directories in order until it finds a binary named cat. More on that next. More PATH So as stated before, when you run a command it will search through the list of directories for the first binary that matches the name and execute it in your current \"context\". $ export PATH=$PATH:/home/dennis/bin This command will set the PATH variable equal to the old PATH with \":/home/dennis/bin\" appended to the end. Now when I run a command, if a program is not found in the first directories, it will search my user's /bin and attempt to run whatever is found there. While this can be useful, it also can be the cause of a security problem. Imagine if instead of the command above we ran $ export PATH=/home/dennis/bin:$PATH. Now if we ran cat the first place checked would be the user /bin we just set, which we could fill up with whatever binary we wanted, named what we wanted. In some interesting attack scenarios, by changing PATH an attack can trick a user (or an automated script) into running a malicious version of a common binary. As always, security is complicated and gets more complicated the deeper we go. To verify which executable is being found on your PATH, run the command which with the first argument the name of the command you want to run. It will print out the path of the executable that will be run. As a note, if you are executing a local executable using the formal ./executableName, you will not use the PATH variable at all. The \"./\" specifies \"in working directory\" so there is no need to go searching. Set Variables set prints all shell variables. printenv prints all environmental variables. The difference is a question of scope. Shell variables are only applicable for the local shell, while environmental variables are passed down to child processes. Does this matter to you really? No! But I will tell you about it hear anyway. Do this tutorial and remember that these are things, I will come back to it eventually. $ FOO=\"dennisIsGreat\"$ echo $FOO dennisIsGreat$ set | grep FOO$ printenv | grep FOO We looked at the export command above with PATH and didn't really explain it, so we will do it now. export adds a variable to the environmental variable group, which means it will now be available to any child processes, as well as the local shell. $ export FOO$ printenv | grep FOO$ bash % echo FOO dennisIsGreat$ unset FOO$ set | grep FOO$ printenv | grep FOO$ export - n FOO$ printenv | grep FOO I bet you can guess what unset and export -n did and if not, google should help out. These last few commands have been bash builtins, meaning they are part of the bash terminal rather than your operating system. For all terminal built-ins there will not be a man page; however, if you need to access local info you can man \\ and then search through the man page for the correct commands. Hope this little adventure into variables and built-ins didn't make your brain hurt too much, because mine sure hurts from writing it. Set Temporary Aliases Much like setting variables, we are going to set an alias for a frequently typed command. Aliases are the Linux term for when we modify the ENV so that running a user-defined command runs a custom command. $ alias lsa=’ls -a’ $ lsa Set Permanent Aliases All of the things we just did were temporary and will disappear the next time you close out your terminal. Let's make all these changes permanent. Your shell is constantly updating its environmental variables so that it knows what the correct configuration is for any point in time, however, there is an initialized configuration the shell will load every time. This is known as your .bashrc file, and is located at ~ in your home directory. Your .bashrc is part of a group of files called dotfiles, so named because they have a dot in front of their names which makes them \"hidden\" files in the Linux directory system. Dotfiles are almost always used to store configuration settings in Linux, and many people use them to customize their experience, such as using .vimrc files to tune Vim. We will talk about them more later, don't run off on me yet. cat ~/.bashrc to check out what is in yours, likely a lot of comments and things that are set equal to values . These variable assignments are critical to how shells function and define desired behavior. Don't worry about what they all do specifically, it doesn't matter much unless you care about modifying your .bashrc (as we will do later). Open up your .bashrc and add the appropriate lines to the end of it in order to permanently alias one command and set a permanent variable. If you are looking for motivation to make a more complicated one If you are interested in dotfiles, check out this link for more info. A .bashrc can be as complicated or simple as you like, and there is near endless customization possible. You will be able to carry this around between computers with you to automatically personalize the box as soon as you load in the .bashrc so its just like home. I recommend commenting it heavily so you remember what things are, and then uploading it to Github so it's easy for you to bring to whatever computer you are using. Consider it a living document. Personally, I don't use them because I bounce around computers so often and I don't like building non-transferrable muscle memory, but they certainly have their benefits and most people love them. Bringing It All Back Together So what happens when you run a command like 'nc -lp 1337' in your shell? Well, the first thing that happens is that the shell is reading STDIN to a buffer. When you press enter, the shell goes and breaks down what you typed into the command it needs to run. Then the shell starts looking for an 'nc' binary in your environmental PATH. The first 'nc' that the shell finds is the one it will take, so as we discussed earlier, you only want to have one executable with with the specified name in your path or weird things are going to occur. You can determine which 'nc' will be used (ie is first in the path) with the which command. Then the shell (which is a process with a PID itself) will fork, meaning it will spawn a new child process, and then that child process will \"exec\" the specified command, in this case, /bin/nc with the appropriate arguments. As a notable point, fork creates a new process, while exec replaces a process. The shell needs to fork first so that the exec occurs in the child process and replaces the child process, rather than replacing the shell itself, which would kill your terminal. This fork/exec process is how all child processes are created. Don't worry too much about exactly how this works for now, but if you are interested check out the man pages for 'fork' and 'exec. The parent process will continue running, independent of the child process, and with 'nc' waiting for an incoming connection we can look at our running processes with ps to identify our child and parent processes. Any output from 'nc' will be sent to STDOUT and STDERR, which will be displayed in the terminal. However, the terminal has the ability to background the child process, as described earlier, so if STDOUT and STDERR aren't being piped anywhere, noone will ever see them. These two processes are running independently now, and killing the parent does not automatically kill the child. However, you may have noticed that if you kill the terminal while a process is running in it, you will be prompted if you want to kill the terminal and it's child process. This is slightly confusing, but it's because the terminal was programmed to send kill signals to its children when it closes for the UX benefit, not because of any inherent property of parent and child processes. Alright, that was a bit much, but I'm glad we talked about it. For your assignment, discuss the process of what happens when you run 'ls', especially how the shell knows what location to print the contents of. Use the usual format. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"AdvancedLinux/13-SubmitaWriteupandGetaCertificate.html":{"url":"AdvancedLinux/13-SubmitaWriteupandGetaCertificate.html","title":"Submit a Writeup and Get a Certificate","keywords":"","body":"One of the best things about CTFs like Bandit is that you can follow someone else's writeup and copy what they have done to solve it yourself. While this might seem like cheating, one of the main benefits of CTFs is that you get exposed to different problem types and learn how to deal with them. Learning how to solve a problem type you've never seen before is a good skill, but it is better to start by learning all the common problems first by following other peoples' writeups. For this assignment, choose one of the problems you solved in Bandit and do a writeup on how someone could replicate what you did, then submit it! Once you've submitted it, email me a copy at d.m.devey@gmail.com and I will send you back the Ropper's Linux Certificate! https://badgr.com/public/badges/6pOR4egxTpKJQZIgTodbqA Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/0-Programming.html":{"url":"ProgrammingBasics/0-Programming.html","title":"Programming","keywords":"","body":"There are plenty of people out there who say you can be good at computers and cyber security without knowing how to program. Those people are wrong. I don't mind being a jerk about it because it ain't gatekeeping if I'm pointing you at the door. If you can't program, you are going to spend a horrible amount of time clicking things and manually doing things that should be automated. Of course, there are exceptions for people with very specific jobs, but for everyone else, a working knowledge of programming and the ability to script anything will carry you as far as you need to go. You will always be learning and forgetting basic parts of the languages you work with, but it becomes easier to get back into an old language or learn a new one every time. But before you can start writing your own malware and machine learning pipelines, it's time to learn the basics of programming, Git, HTML, and get proficient with Python. Programming Languages This is important. Try to really understand the breadth of what programming languages are. Introduction to Programming Languages https://en.wikiversity.org/wiki/Introduction_to_Programming/About_Programming Hello World in a variety of Languages. Check out bash, python, c, assembly, and perl. https://rosettacode.org/wiki/Hello_world/Text In your own words, describe what a program is. In your own words describe what a programming language is. I like to think of it as anything that you can put text down and create something else that does a thing. Do graphical programming languages count? I don't know, but you can use them to make very impressive programs, so... count it! Are HTML and CSS Programming Languages? There is a common gatekeepy thing where people say that \"front end\" or \"UI\" developers aren't real programmers if they only work with HTML and CSS. It's pretty messed up, and it is very often driven by sexism. So let's get something out of the way... writing HTML and CSS is ridiculously hard and I have the utmost respect for anyone who can make a website not look terrible (like my website... it looks so bad). With that said, HTML and CSS are not programming languages according to the exact definition of the word. Anyone who uses them is a coder and a developer, and yes, a programmer, but the languages themselves really don't fit the definition. As a general rule, if you see someone saying that HTML and CSS aren't programming languages, they might be technically correct, but most of the time they are trying to provoke a fight. Those people are not worth your time. Alright, with that out of the way, time to learn how to program in HTML and CSS! Teach Yourself Programming in 10 Years I should write some more about this, but I think it is an excellent read. This is an expert programmer's article on what it takes to learn how to program, with a good discussion of a lot of the ideas that I lean into throughout this course. https://norvig.com/21-days.html Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/1-ModernIDE.html":{"url":"ProgrammingBasics/1-ModernIDE.html","title":"Modern IDE","keywords":"","body":"IDEs or Integrated Development Environments are tools with the ability to run and debug code, as well as write it. They often have deep integrations meant to make you more productive, like code completion and syntax highlighting. Plenty of text editors, including vim and emacs, have functionality named \"plugins\". Plugins are software that can be added to existing tool to extend what they are able to do. For these text-editors, the plugins are used to add helpful tools that makes it easier to write code fast and well. I used to recommend people turn vim into a mostly fully featured IDE, using a fancy shmanch .vimrc file. This dotfile, similar to the .bashrc you made in the last section, is used to configure vim on startup. Alas, I no longer believe in using vim as an IDE. Instead of configuring vim to do a lot of things it was never meant to do, just install Visual Studio Code for Linux. It is absolutely awesome and you can install all sorts of great syntax checkers and auto-completer extensions for your favorite languages. For your assignment, install VS Code for Linux. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/2-GitHelloWorld.html":{"url":"ProgrammingBasics/2-GitHelloWorld.html","title":"Git Hello World","keywords":"","body":"Open Source You might have heard of Open Source before, as there has been an infinite amount written about the subject, but this is a good time to learn about it. In fact, this course is entirely open source! Open source and hacking go hand in hand. You might not feel strongly about it now, but you probably will eventually. What is Open Source? https://opensource.com/resources/what-open-source Git Before we get to Github we have to learn about the software it is built around, which is named 'git'. Git was developed by…. drumroll… Linus Torvalds! Basically, once he started working on Linux with a bunch of other programmers, he needed a dedicated type of software so everyone could work on different pieces without stepping on each other's toes. What was created is something now known as a “version control system” or VCS. There are a variety out there, but Git is clearly dominant. Git is used for version control during software development, allowing collaboration and the merging of changes in a safe and easy manner. It is used by just about everyone and is amazing. If you want to build large pieces of software, especially as a group, you need to use version control. However, as you’re about to find out, git can be a bit of a beast to manage. Github Luckily, some helpful folks decided to add features to git that old Linus would have never agreed to, and now we have Github. Github is a website that wraps git and allows you to share your code via their website, as well as letting you download other people's code. It’s The Place for sharing the source code of your digital creations with the world, and checking out what others have written. Repositories The way git works is by manipulating things named “repositories” or “repos”. By keeping track of all the code, and all the changes to the code over time, git is able to show snapshots of what the code looks like at different points. Inside of each repo there can be multiple “branches” which git will also keep track of. This means that different programmers can be working on different branches inside of one repo, and then “commit” their changes to the main branch. The git software will keep verify nothing conflicts, keep track of who did what when, and then “merge” all the code together. We can host our git repos locally or somewhere in the cloud. The primary objective of Github is to be that remote location to store git repos. Github and git knowledge is basically required for any programmer job, so let’s do a quick lab to drive home how that works. Tutorial First, make a github account at https://github.com Then ensure git is installed on your computer with \"git status\". If it is not, install git. Once you have verified that you have git on your computer and made a Github account, it is time to 'fork' my repository https://github.com/hoppersroppers/demoHtml. Forking is the cool programmer word for making a personal copy of a repo. There are multiple ways you can do this, but the way we will do it here, will combine the Github Web Interface and some CLI action. First, \"fork\" https://github.com/hoppersroppers/demoHtml via the Github website by clicking the fork button in the top right. Now you can refer to your repo as a fork of mine, which honestly sounds cool, plus it makes sense! Now, let's clone your fork to your computer. $ git clone https://github.com/---yourUserName---/demoHtml This will make a local copy of your fork on your computer. Keep in mind, this is not considered forking your fork, simply cloning. Check that the repo downloaded with ls and then cd into it. Files in the Git Repo Use ls to see what is in the directory. You should see hello.html, README.md, and a LICENSE. README.md is the common name of the file used to understand what is going on in the repo. If you visit your repo you forked you will see that the README is displayed to you when you click in. LICENSE is the common filename of the Open Source license the file is released under. There is a ton of complexity in this that is basically copyright law, so for now don’t worry about it, but just know that it is important to check these out before blindly taking someone else’s code and using it in your work. You can click to your Repo in Github to see what the License is in the top line. Finally we have hello.html. It’s a regular HTML file which is the language websites are built with. We can render it in our browser by opening it and selecting our browser as the correct program. We can also edit it by selecting a text editor to open it, liked gedit or one of our command line options. If you've ever looked at \"View Source\" in your browser before, you were looking at HTML. Editing Our First File First, run git status to check out how everything is going. If you get errors, figure them out before moving forward... as I like to say, the best time to fix merge issues is before you find out about them. status will tell you right now that you are in branch \"main\". \"main\" is the default branch name for a Github repo. It is possible to switch branches and have different changes in each branch, but for now, everything we will do is in main. Git has man pages, but basically instead of flags, we have a family of commands we run as the second argument. When you’re having issues with git, basically the right move is to check out google and find a useful resource for the problem you are having. Search the error code and someone out there will have fixed it before, I promise. After we check status, edit your hello.html file and change what the text says in the header and body. Verify in your browser that the change worked! Now run git status again! What changed? You will be seeing that you have one “untracked” file now, basically meaning that git knows you made changes but isn’t going to do anything with them. So first, you have to get that file to be “tracked”. $ git add hello.html To be even faster, you could have run $git add *. Now check git status again. Verify your changes have been tracked and let’s commit them! $ git commit -m \"modified hello\" That commit -m puts your tracked changes into the local repo, and writes a message to the log with whatever you specified. If this fails, and it will if you've never set up git on your local computer before, run the commands in the error message to set your name and email. Once that has been done, run the commit again and it should work! Check git status to ensure your commit worked. You should see now that you are one commit ahead of the remote repo. If you check that remote repo on Github you will see that nothing has happened there yet. To get something to happen on Remote, you need to “push”. Before pushing, we need to know the name of remote. Most of the time we can guess it will be origin, but if you are doing fancier things really anything could be there. To check the name, run git remote. After verifying the name is origin, run git push origin main. You will get an error message here! Github has decided to no longer allow password-based authentication for pushing to repositories. You can read more about this here: https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/#what-you-need-to-do-today Using Google and links provided to you, generate a personal access token and use that to authenticate the next time you push. Make sure to save that access token somewhere safe, and don't commit it to any of your git repos!!!! Once git push origin mainhas succeeded, check your github repo and verify the changes have been made. Congratulations on your first ever push! Pull! Now, let’s get a pull in! Pulling is the act of taking code from somewhere else and bringing it into a repository. First, let’s make a change in your Github repository! From the website, update the name in your README.md to say your name by clicking on the edit button in the GUI and committing your changes. You can probably guess by now that your local copy of the repo will not have that change yet, but you can verify if you want. So now, your local repo is one commit behind the remote one… time to fix that! $ git pull origin main Git pull combines two commands “fetch” and “merge”, which fetch the remote repo and merge the two repos together. For more complicated things, you might have to or want to fetch and merge separately, but life is easier with a one command pull on a simple repo like this. Verify the change has been made locally and congrats! You now have more git knowledge than the average computer science graduate. Practical skills rock! All things considered, git and Github are incredibly complicated and this simple little demo might have oversimplified things, but honestly... this is good enough to start! You'll be using plenty more git throughout the rest of the course and believe me, you will find plenty of ways to break it, and then fix it back up again. (And worst comes to worst, you can always just make a new repo!) Assignment: Explain what open source is in a few sentences and what the benefits are. Submit a link to your first repo Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/3-GithubandCompilewithMake.html":{"url":"ProgrammingBasics/3-GithubandCompilewithMake.html","title":"Github and Compile with Make","keywords":"","body":"While often we lean on our package managers for installing new programs, every once in a while we will find ourselves forced to build a program from source. This can seem very daunting, especially if you don't understand how compilation works. The good news is... you don't have to! The vast majority of the time you can just look for a repository with good installation instructions (Specifically, a list of commands to run), download the repo, run the commands, and verify everything worked. It's very daunting, but most of the time it will go smoothly... the author wouldn't have it on their Github if they didn't think it would work, right? To demonstrate this idea of building a C program with make, follow the README.md in this repo. Before cloning, ensure to \"Fork\" the repo into your own account so you can modify it. https://github.com/hoppersroppers/makeDemo Once you have cloned the repo, modify the function to print your name, commit your change, and then push the changes to your remote repo. Submit a link to your commit as the assignment. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/4-WebHackits.html":{"url":"ProgrammingBasics/4-WebHackits.html","title":"Web Hackits","keywords":"","body":"Hackits are a fun way to learn HTML, CSS, and some javascript. They are very similar to a CTF, but are a little more straightforward and are pretty narrowly scoped. In fact, some of these challenges could be CTF challenges! Check out this page, it's a fun thing to do! https://www.0xf.at/. Things get hard but it's fun to come back to! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/5-BuildaWebsitewithHTMLCSSandJavascript.html":{"url":"ProgrammingBasics/5-BuildaWebsitewithHTMLCSSandJavascript.html","title":"Build a Website with HTML CSS and Javascript","keywords":"","body":"Github is pretty awesome, but somehow, they just keep doing more and more for us. One really awesome thing they do is called Github pages, where they will build and host a website for us if we put all the code into the correct Github repo. The way that actually works is pretty complicated, but from our perspective, it's just a magic personal website, for free! As a matter of fact, https://hoppersroppers.org is run off Github pages and is actually https://hoppersroppers.github.io! Pretty cool eh? Using the demoHtml repo you forked off in the first git assignment, convert it to a Github pages site using this guide. Notably you will have to change the name of the repo to your username on Github for this to work properly, but there are a few other little things I am confident that you will be able to figure out. On that same note, you'll be able to figure this out. I'm not going to give you an HTML tutorial. Think of it like the Regex section, this is for appreciation, not understanding. I want you to trial and error it, google things, find code snippets, and just make something that makes you happy. Make that site your own! My favorite student made site so far was this one by Mr. Ashley Ball. I think it does a better job teaching than most tutorials. Your requirements for this site are: Have a solid color background Have at least one image Have at least one hyperlink Have at least one snippet of Javascript that adds an OnClick event. https://www.w3schools.com/jsref/event_onclick.asp Use CSS to make your font look pretty! Feel free to make it as complicated or basic as you would like, and have fun playing around with it. I recommend this site: https://www.w3schools.com/html/default.asp Web development is an incredibly massive field and I don't plan to teach you here. This is just meant to be enough for you to slightly understand how it works and get an appreciation for the hard work that goes into beautiful websites. Plus, now you have a way to show your work to friends and family! Submit a link to your github.io site. Explain what the OnClick event does and how it works. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/6-BasicBashScripting.html":{"url":"ProgrammingBasics/6-BasicBashScripting.html","title":"Basic Bash Scripting","keywords":"","body":"Bash has a built in scripting language, which I guess is pretty cool. These days, you should just use Python for most things instead of writing Bash scripts, but you would be horrified if you knew how much of the internet, nay, how much of the world runs on bash scripts. Most servers? Of course. Water plants? Absolutely. Nuclear reactors? I'd be shocked if there wasn't a cron-jobbed bash script running somewhere in every plant in the world. Don't tell anyone, but a great deal of this site runs on janky cron jobs. Because bash and cron jobs (which we'll learn about later) are basically the underpinning of the modern world, you should probably get to know them. Bash Scripts Open up your favorite text editor and build a file that looks like this and save it as \"hello.sh\". Note the top line which tells the shell what type of script it is, the file extension doesn't matter at all. #!/bin/bash echo \"Hello World\" Then you can execute it using the command $ bash hello.sh. Similarly, you can use chmod to mark the file executable and then execute it using $ ./hello.sh. As you might have noticed, the command you are running is exactly what you would run in a normal terminal command. Does that mean most of the knowledge you've learned remains applicable in here? In a shocking turn of events, yes, it does. Don't get used to things working this nicely in the future. More Advanced Scripting Check out what we can do to take input and execute commands in a script. Just build the script, save it whatever you want, make it executable and run it. Don't worry about understanding it, I'm trying to demonstrate capability, not teach you how to do things at this point. #!/bin/bashecho \"Enter Your Name\"read name# read is a nice little bash builtin function that isn't available in the shell,# but is in the scripting language. Also, lines starting with '#' are known as comments and aren't executed, these are in all languages, you'll get used to them. date=\"$(date)\"# We just set the value that date returns to date# using something called \"command substitution\".# Unsurprisingly, you can do very complicated things with that.echo \"Welcome $name it is $date\" And finally, here is a program that counts to 10, printing out all the numbers as it goes. Save it as counter.sh in your Documents directory and run it with ./counter.sh. #!/bin/bashvalid=truecount=1while [ $valid ]doecho $countif [ $count -eq 10 ];thenbreakfi((count++))done Don't worry about what is going on in there, just know we can do whatever we want using bash scripting, though we probably should use something more modern like Python. Still, good to have in a pinch. Cron Jobs Sometimes you might find yourself needing to run a command every couple of minutes, and luckily, there is a wonderful Linux tool for that named crontab. These commands can be anything, from kicking off shell scripts, starting python processes, checking that programs are still running, really anything you want to schedule, cron jobs are the right way to do it. A crontab file contains instructions for the cron daemon in the following simplified manner: \"run this command at this time on this date\". Each user can define their own crontab file. Commands defined in any given crontab are executed under the user who owns that particular crontab. To see what is in your crontab file, run crontab -l. To edit it, run crontab -e. Add this to the bottom of your cronjobs to execute the counter.sh script every minute. */1 * * * * /home/studentName/Documents/counter.sh Alright, that incantation on the front that says when to run can be a monstrosity, especially when it comes to more complicated timing, so don't learn it and just use existing examples on line. I use this site (https://crontab.guru/examples.html) for all my crontab-ing needs. (You better believe that Roppers run on crontabs and janky Python scripts). If you want to spend more time learning about Bash, check out https://tryhackme.com/room/bashscripting , but promise to come back to Roppers. Assignment: Write the bash script to append the date and time the script was run to a file named \"dates.txt\" Write the cron command to run the script you just wrote every Friday at noon. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"ProgrammingBasics/7-Python.html":{"url":"ProgrammingBasics/7-Python.html","title":"Python","keywords":"","body":"It's time for you to learn your first programming language! Sort of! I don't want to teach you programming as part of this course, it doesn't fit into what I want to accomplish. What I want to accomplish is getting you exposure to things that will open your mind to what is out there and give you the skills to get things done, and the programming language Python is perfect for that. Python is a programming language that has found incredible success, largely due to the fact that code written in it is readable and things just work. Programming is an exacting art, and Python doesn't force you to work very hard to understand why things are the way they are. Other languages, specifically C are better for learning the nitty-gritty, which so far has been what this course focused on. So why are we starting with Python? Simply, Python gets things done. It just works. And for the beginning programmer, I don't want you to have to worry about all the crap that other languages make you care about. What I care about is you have the ability to do things, whether that is automate your life or to crush CTF challenges. While Python isn't the most popular programming language yet, it will be in the next few years. It runs the backends of many giant companies, but also is the dominant language for data science, and is the language of choice for many people who need to move fast and get things done. (That's us!) Again, no language is perfect. There are tradeoffs with all languages, some do better than others at various activities, some are worse. Python is the most straightforward language to write code and do things with, and has the best documentation examples for you to work off of. It is considered to be \"slow\", but when people tell you that, ignore them and continue writing your code. You will be done writing your program by the time they start trying to troubleshoot why their program doesn't work. Don't argue with people about programming languages, anyone who does that for fun is the worst. Just let them have it. What is Python? Python is a language developed primarily by Guido van Rossum, the affectionately named 'Benevolent Dictator for Life'. He began work on it in 1989 and since then thousands of people have contributed to the core code base, and even more have written modules and extensions to allow more to be done with the language. Potentially the most important design consideration for the language was that it was developed to be highly extensible, making it as easy as possible for people to build extensions to allow programmers to use others' code in order to do more with less lines of code. Other aspects of the Python philosophy are: Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Readability counts Overall, Python is often described using the words: High level, interpreted, dynamically typed, garbage collected, readable. For the assignment you'll define those. Don't worry about what dynamically typed means right now. As a fun note, the language is named for Monty Python's Flying Circus, a legendary British comedy show from the 70s. I really recommend you watch some of their sketches, or the movie Monty Python and the Holy Grail. It's on Netflix, but many of the sketches are on Youtube. Python Hello World This might require some googling..... don't worry, that is how everyone does it. You find something you need to do, and google how to do it. Then you forget how to do it, and you go and google it again the next time you do it. The next bit will help you set up your python environment on Linux. Setting up environments is very time-consuming, no matter what it is, but you will have to do this for basically every language, and every version of each language, so you will have to get good at it. On Linux Ensure the most up to date version of Python is installed on your Linux box. Check this by running the command python from the command line. If it responds with Python2 or the program is not installed, install a modern Python version with https://docs.python.org/3/using/unix.html#on-linux When you run python from the command line it brings up something called an interpreter. The Python interpreter is neat because you can use it to run programs one at a time. With the interpreter open, do some basic math. a = 2 b = 3 c = a + b print(c) That should have printed c, which would have displayed as 5. You can also print text from the interpreter. A program that prints \"Hello World!\" to the screen is the classic first thing most tutorials teach. Far be it from me to break with tradition, so here goes! print(\"Hello World\") Make sure to have the quotes around the words that you printed. Don't worry about what is happening right now, this is just to show what is possible. To close out the interpreter, type exit(). Hello World We used the interpreter, but you can only do very basic programs from the interpreter, so usually you run python programs as their own files. Python makes this incredibly easy in comparison to many other languages. Here is the code: print(\"Hello World!\") You might notice that as the same thing that the interpreter took as input. Save it as \"helloworld.py\". \".py\" is the python file extension. It is just a text file, but the \".py\" tells the OS what to do with the file if you try to execute it. Then, from the terminal, run that file you just created with: $ python helloworld.py Congratulations! Now you know how to program in Python! Sure, there are a few steps between here and writing more complicated programs, but... you'll get there! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"NextSteps/0-ShowWhatYouKnow.html":{"url":"NextSteps/0-ShowWhatYouKnow.html","title":"Show What You Know","keywords":"","body":"I talk a big game about all of this being about what you know and what you can do, but there is something I have to tell you. If you do not prepare the way you present yourself, put yourself out there, and be willing to fail, or be ignored, or be turned down, you're never going to be able to put the skills and knowledge to work. You have to be willing to enter the arena, especially if you are not feeling \"ready\" for it. You have learned (really taught yourself) VMs, Linux, how to build a website, and wrote some complicated Python programs. Every single thing in security and computing derives from these things. The next steps are harder to figure out, but hopefully the Roppers Roadmaps can assist. Now, for the important stuff: At the beginning of the class I told you that I will help you with your resume once you get this far, and I meant it. Go and update your resume with everything you have done in this course and make sure to add links to your git repos. Once you have it done and formatted, email it to me at d.m.devey@gmail.com with the Subj: Roppers Resume Review . When I can, I'll look it over and give you some feedback. I also strongly encourage you to turn a few assignments into blogposts, and do writeups on some of the programs you wrote and things you learned. Fill out that personal website to show that you are a professional and have the ability to do technical writing. As much as I wish it was all hacking, most jobs care about your reading and writing ability just as much. If you want to, I can put you on the Roppers job board. It will be a place on our site that anyone can click to find some information about you and your resume. I won't be a middle man for that, but if you want to get yourself visibility, I'd love to help. I can also tweet and see if anyone in the network is looking to hire. I'm here to educate, but I'm really here to try and help you out. Now that you have gotten this far, let me know how. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"NextSteps/1-HowtoLearnPython.html":{"url":"NextSteps/1-HowtoLearnPython.html","title":"How to Learn Python","keywords":"","body":"As mentioned before, I don't want to teach you programming as part of this course. If you are interested in learning Python, you should follow these steps, but all of this is optional and certainly not required to complete the course. As this is basically the end, you're done now! Codecademy Python 2 This is going to take a while, but Codecademy Python is the best way I've found to learn a first programming language. It is all done in an online editor and will let you progress with the appropriate hints. While you are working through this, use the amazing PythonTutor Visualization anytime you are trying to understand what is going on behind the scene with your code. It's super helpful and will help you understand debugging in a visual manner. NOTE: If you already know a programming language and don't need to re-learn what a tuple is, or are already learning Python using a different site or course, let us know. We can customize your experience here, there is no hard rule you have to use Codecademy. NOTE: If you are confident in your Python ability, submit a statement that you think you are ready to move forward and head on to the next section. NOTE: Codecademy teaches the slightly outdated Python 2 language, instead of the more recent Python 3. This is not really a problem, the language is basically the same and what we are worried about is you learning how programming works, not exact syntax. Once you know Python 2, 3 is a just a few steps different. The rest of this course will have you develop in Python 3, so you can build the skill of mentally translating syntax and learning a new language on the fly, a critical part of being a developer. Keep us updated in Slack on your progress. When you are done, submit a screenshot of your completion certificate!! https://www.codecademy.com/learn/python If you get bored... just move on. Codecademy can kind of drag, and if you're bored, just keep moving. I promise you'll be fine without it for now, you'll just have to learn Python for real eventually. No boredom, no drudgery! Automate the Boring Stuff If you want to get good at programming, you should go and complete all the exercises in Automate the Boring Stuff (https://automatetheboringstuff.com/) in Python 3. Once you have done that you will be capable of just about any scripting task in Python if you have the time to do your research and work through it. For now, I just want you to work through Chapters 9-12 of the Automate the Boring Stuff curriculum. We skip the first few chapters, but you generally have learned them from CodeAcademy already. If you're having trouble with Chapter 9 (you probably will), step back a few chapters and work through them until you feel comfortable moving forward. https://automatetheboringstuff.com/2e/chapter9 How to Learn C: If you want to learn C, and you should to get a deeper understanding of computing, check out my rough roadmap once you have finished this course. Projects Worth Doing This is a random assortment of projects in different languages that I think are interesting. https://www.hoppersroppers.org/library/interestingProjects.html Teach Yourself Computer Science If you really want to learn Computer Science properly, I recommend you work through https://github.com/ossu/computer-science/blob/master/README.md. It's a fairly comprehensive education. I'm not a big believer in the importance of computer science to be a good hacker, but if you're someone who wants that academic background, it's worth checking out. \"Computer Science\" is far outside of the scope of this course, so I'd prefer if you stuck around here, but the entire point of learning is following what you are interested in. No hard feelings if you go, just promise to come back! If you go this route, I recommend you start at this course, as you already have some python experience. https://github.com/ossu/computer-science/blob/master/README.md#introduction-to-programming Programming is something that takes a lifetime to get good at, so don't worry about being good at it for a while. Focus on making things that work just well enough to get the job done. Roppers Academy 2021            Date： 2023-11-11 00:31:41 "},"NextSteps/2-WhatCourseNext.html":{"url":"NextSteps/2-WhatCourseNext.html","title":"What Course Next","keywords":"","body":"If you have come this far, we believe you are ready for the next step in your journey. If you haven't yet, you should check out the Security Fundamentals: Theory and Practice course. I think it is pretty awesome. The next technical course for you is to jump into the Intro to Capture the Flags course, where you will learn about data manipulation, cryptography, file formats, and some basic forensics. If you want to focus on networking you can skip the Introduction to CTF course and head straight for Learning Networking with CTFs. That course is in progress, but should be pretty decent (eventually). You can teach yourself at least. Don't stop your journey here, keep on moving! Roppers Academy 2021            Date： 2023-11-11 00:31:41 "}}